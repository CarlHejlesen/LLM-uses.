{
  "filePath": "./random.pdf",
  "pages": [
    {
      "number": 1,
      "originalText": "",
      "claims": []
    },
    {
      "number": 2,
      "originalText": "CARL: A Roguelike Language\n- A Language to Simplify the Generation of Maps for\nRoguelike Games -\nProject Report\nSoftware 4 Group 16\nAalborg University\nDepartment of Computer Science",
      "claims": []
    },
    {
      "number": 3,
      "originalText": "Copyright © Aalborg University 2024\nTools used for writing this report and making the entire project.\nBrowsers: Chrome, Firefox, Microsoft Edge.\nWriting:  Google,  DuckDuckGo,  Bing,  ChatGPT(3.5,  4),  Bing  AI,  LanguageTool,  Overleaf\n(LaTeX).\nOrganization: Discord, Google Drive, Obsidian.\nCoding: ChatGPT(3.5, 4), Visual Studio Code, IntelliJ IDEA, vim, GitHub, git.\nOperating Systems: Windows (10, 11), macOS, Linux (Arch, NixOS).",
      "claims": [
        {
          "text": "Copyright © Aalborg University 2024",
          "flag": false
        }
      ]
    },
    {
      "number": 4,
      "originalText": "",
      "claims": []
    },
    {
      "number": 5,
      "originalText": "Department of Computer Science\nAalborg University\nhttp://www.aau.dk\nTitle:\nCARL: A Roguelike Language\nTheme:\nDesign,  Definition and Implementation\nof Programming Languages\nProject Period:\nSpring Semester 2024\nProject Group:\ncs-24-sw-4-16\nParticipant(s):\nCarl Skovgaard Hejlesen\nLennart Diego Kahn\nMantas Akilanas\nMohammad Shadi Sheikh Fares\nOmar Domani\nVincent Kosteyev Bechmann\nSupervisor(s):\nMartin Moesmann\nCopies:1\nPage Numbers:131\nDate of Completion:\nJune 4, 2024\nAbstract:\nThis  report  details  the  design,  imple-\nmentation,   and   testing   of   an   inter-\npreter  and  language  named  \"CARL\",\na  domain-specific  programming  lan-\nguage tailored for the creation of pro-\ncedural  map  generators  for  roguelike\ngames.  Aimed to support indie devel-\nopers,  CARL  addresses  the  common\nchallenge of generating random maps\nin  roguelike  development.The  lan-\nguage  features  basic  constructs,  such\nas  if-statements  and  while-loops,  and\nsupports operations between different\ndata types to enhance readability and\nwritability.The  interpreter  also  has\nbuiltin   functions   that   allow   for   the\ngeneration of a map with only 5 lines\nof code.  Key aspects of the implemen-\ntation  include  the  use  of  ANTLR  for\ngenerating  a  lexer  and  a  parser,  and\nthe  development  of  an  interpreter  in\nJava for immediate code execution. Ex-\ntensive testing,  including unit and in-\ntegration  tests,  was  conducted  to  en-\nsure  robustness,  correctness,  and  ad-\nherence to specified requirements. The\nreport  concludes  that  CARL  success-\nfully  meets  its  objectives,  providing  a\npotentially  user-friendly  and  efficient\ntool for roguelike game development.",
      "claims": [
        {
          "text": "CARL is a Roguelike Language",
          "flag": false
        },
        {
          "text": "CARL is designed for the creation of procedural map generators for roguelike games",
          "flag": false
        },
        {
          "text": "CARL addresses the common challenge of generating random maps in roguelike development",
          "flag": false
        },
        {
          "text": "CARL features basic constructs, such as if-statements and while-loops",
          "flag": false
        },
        {
          "text": "CARL supports operations between different data types to enhance readability and writability",
          "flag": false
        },
        {
          "text": "The interpreter has built-in functions that allow for the generation of a map with only 5 lines of code",
          "flag": false
        },
        {
          "text": "ANTLR is used for generating a lexer and a parser in CARL implementation",
          "flag": false
        },
        {
          "text": "CARL implementation includes development of an interpreter in Java for immediate code execution",
          "flag": false
        },
        {
          "text": "Extensive testing was conducted to ensure robustness, correctness, and adherence to specified requirements",
          "flag": false
        },
        {
          "text": "CARL successfully meets its objectives providing a potentially user-friendly and efficient tool for roguelike game development",
          "flag": false
        }
      ]
    },
    {
      "number": 6,
      "originalText": "The  content  of  this  report  is  freely  available,  but  publication  (with  reference)  may  only  be  pursued  due  to\nagreement with the author.",
      "claims": [
        {
          "text": "The content of this report is freely available",
          "flag": false
        }
      ]
    },
    {
      "number": 7,
      "originalText": "",
      "claims": []
    },
    {
      "number": 8,
      "originalText": "",
      "claims": []
    },
    {
      "number": 9,
      "originalText": "Institut for Datalogi\nAalborg Universitet\nhttp://www.aau.dk\nTitel:\nCARL: A Roguelike Language\nTema:\nDesign, definition og implementation af\nprogrammeringssprog.\nProjektperiode:\nForårssemester 2024\nProjektgruppe:\ncs-24-sw-4-16\nDeltager(e):\nCarl Skovgaard Hejlesen\nLennart Diego Kahn\nMantas Akilanas\nMohammad Shadi Sheikh Fares\nOmar Domani\nVincent Kosteyev Bechmann\nVejleder(e):\nMartin Moesmann\nOplagstal:1\nSidetal:131\nAfleveringsdato:\n4. juni 2024\nAbstract:\nDenne rapport beskriver designet, im-\nplementeringen,  og  testningen  af  for-\ntolkeren   og   programmeringssproget\n\"CARL\", et domænespecifikt program-\nmeringssprog,  der  skræddersyet  til  at\nskabe  proceduremæssige  generatorer\naf  kort  for  roguelike  spil.  Med  for-\nmålet  at  støtte  selvstændige  spilud-\nviklere,  hjælper  CARL  med  den  al-\nmindelige   udfordring   af   at   genere-\nre  tilfældige  kort  i  roguelike  spilud-\nvikling. Sproget indeholder grundlæg-\ngende  konstruktioner  som  ’if’  erklæ-\nringer,  ’while’-løkker,  og  understøtter\noperationer mellem forskellige dataty-\nper til at gøre koden nemmere at skri-\nve  og  læse.  Fortolkeren  har  også  ind-\nbyggede funktioner, som tillader gene-\nrationen af kort i kun 5 linjer af kode.\nVigtige  aspekter  af  implementeringen\ner f.eks. bruget af ANTLR til at gene-\nrere lexer og parser, og udviklingen af\nen  fortolker  i  Java  for  øjeblikkelig  ko-\ndeudførsel.  Omfattende  testning,  her-\nunder enheds- og integrationstest, var\nunderført  til  at  sikre  robusthed,  kor-\nrekthed, og udførsel af specifikke krav.\nRapporten  konkluderer,  at  CARL  har\nopfyldt sine mål, ved at give et poten-\ntielt brugervenligt og effektivt redskab\nfor udvikling af roguelike spil.",
      "claims": []
    },
    {
      "number": 10,
      "originalText": "Rapportens indhold er frit tilgængeligt, men offentliggørelse (med kildeangivelse) må kun ske efter aftale med\nforfatterne.",
      "claims": [
        {
          "text": "Rapportens indhold er frit tilgængeligt",
          "flag": false
        }
      ]
    },
    {
      "number": 11,
      "originalText": "",
      "claims": []
    },
    {
      "number": 12,
      "originalText": "Contents\n1    Introduction1\n2    Problem analysis3\n2.1The Roguelike genre   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .4\n2.2Map generation and algorithms .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .8\n2.3Current solutions   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .11\n2.3.1Libraries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .11\n2.3.2The Role of Libraries in Roguelike Development    .  .  .  .  .  .  .14\n2.3.3Game Engines .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .14\n2.4Target audience   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .15\n2.5Problem definition   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .16\n3    Requirements17\n3.1Prototype .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .18\n3.2Criteria for Programming Languages    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .21\n3.2.1Readability, Writeability and reliability   .  .  .  .  .  .  .  .  .  .  .  .  .21\n3.3MoSCoW requirements .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .26\n3.3.1Must Have .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .26\n3.3.2Should Have .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .28\n3.3.3Could Have   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .28\n3.3.4Won’t Have   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .29\n3.4Summary .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .30\n4    Language design31\n4.1Paradigm .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .31\n4.2Syntax    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .32\n4.2.1Data Types and Structures    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .32\n4.2.2Operators   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .35\n4.2.3Control Structures   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .37\nxi",
      "claims": [
        {
          "text": "The Roguelike genre is a type of video game.",
          "flag": false
        },
        {
          "text": "Map generation and algorithms are important aspects of Roguelike development.",
          "flag": false
        },
        {
          "text": "Libraries play a role in Roguelike development.",
          "flag": false
        },
        {
          "text": "Game engines can be used for Roguelike development.",
          "flag": false
        },
        {
          "text": "The target audience for this project is [insert specific description].",
          "flag": false
        },
        {
          "text": "A problem definition needs to be established.",
          "flag": false
        },
        {
          "text": "Prototyping is an important step in the development process.",
          "flag": false
        },
        {
          "text": "Criteria for programming languages should include readability, writeability, and reliability.",
          "flag": false
        },
        {
          "text": "MoSCoW prioritization is a useful method for requirements gathering.",
          "flag": false
        },
        {
          "text": "The paradigm of this language design is [insert specific description].",
          "flag": false
        },
        {
          "text": "The syntax of this language includes [insert specific features].",
          "flag": false
        }
      ]
    },
    {
      "number": 13,
      "originalText": "xiiContents\n4.2.4Built-in functions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .39\n4.2.5Context-free grammar  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .41\n4.2.6Lexer  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .42\n4.2.7Parser    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .43\n4.3Semantics    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .45\n4.3.1Abstract syntax  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .45\n4.3.2Formation rules  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .46\n4.3.3Denoting the syntax values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .47\n4.4Environment store model   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .48\n4.4.1Scope rules in CARL  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .48\n4.4.2Variable model   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .50\n4.4.3Transition system  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .51\n4.4.4Type system  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .55\n5    Implementation61\n5.1Choosing Between a Compiler, Transpiler or Interpreter   .  .  .  .  .  .  .61\n5.2Codebase setup   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .63\n5.3Generating the Lexer and Parser with ANTLR  .  .  .  .  .  .  .  .  .  .  .  .  .63\n5.4Concrete Syntax Tree to an Abstract Syntax Tree  .  .  .  .  .  .  .  .  .  .  .  .64\n5.5Semantic checker   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .69\n5.5.1Variable Declaration   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .69\n5.5.2Get Type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .71\n5.5.3Error handler   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .72\n5.5.4If & while   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .73\n5.5.5Structs & functions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .74\n5.6Evaluation/Execution    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .76\n5.6.1Dynamic Scope  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .76\n5.6.2Builtin functions   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .78\n5.6.3Struct like   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .80\n5.6.4Summarizing of the Implementation    .  .  .  .  .  .  .  .  .  .  .  .  .  .82\n6    Testing83\n6.0.1Purpose of testing    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .83\n6.0.2Code coverage    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .83\n6.1Unit test    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .84\n6.2Integration test    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .85\n6.2.1Integration tests of the semantic checker   .  .  .  .  .  .  .  .  .  .  .  .86\n6.2.2Type checking .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .87\n6.2.3Integration tests of the Evaluator/Executor .  .  .  .  .  .  .  .  .  .  .88\n6.2.4Summary of tests  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .89\n6.3Acceptance Testing   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .90\n6.3.1Objective  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .90",
      "claims": []
    },
    {
      "number": 14,
      "originalText": "Contentsxiii\n7    Discussion95\n7.1Language design   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .95\n7.1.1Criteria fulfilment    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .95\n7.1.2Control structures and operators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .96\n7.1.3Function scope   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .97\n7.2Implementation  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .97\n7.2.1Language Selection in Interpreter Development  .  .  .  .  .  .  .  .97\n7.2.2Robustness In CARL  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .98\n7.3Fulfilment of requirements    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .99\n7.3.1Must haves    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .99\n7.3.2Should haves   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    100\n7.3.3Could haves  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    101\n8    Future Work103\n8.1Introduction  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    103\n8.2Improvement of structs .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    103\n8.3Future scope rules for CARL   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    103\n8.4Enhancements in Error Handling  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    104\n8.5Increased Testing Coverage   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    104\n8.6Implementation of Language Server Protocol (LSP) and Tree-sitter   .    104\n8.7Improved Typing Syntax and Type Inference  .  .  .  .  .  .  .  .  .  .  .  .  .  .    105\n8.8Proper Implementation of the Visitor Pattern  .  .  .  .  .  .  .  .  .  .  .  .  .  .    105\n8.9Non-fulfilled Requirements   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    106\n8.9.1Should Have .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    106\n8.9.2Could Have   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    106\n9    Conclusion109\nBibliography111\nA   Extra Criteria explained115\nB   Context-Free Grammar117\nC   Acceptance test written in CARL language121\nD   ProgrammingintheCARLscriptinglanguage\n125\nD.1   Variables   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    125\nD.1.1    Declaration   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    125\nD.1.2    Primitive Types  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    125",
      "claims": []
    },
    {
      "number": 15,
      "originalText": "xivContents\nD.1.3    Arrays   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    126\nD.1.4    Structs   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    126\nD.2   Operators    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    128\nD.3   Control structures .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    129\nD.3.1    If statements .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    129\nD.3.2    While loops   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    129\nD.4   Functions .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    130\nD.4.1    Defining custom functions    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    130\nD.4.2    Builtin functions   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    130",
      "claims": [
        {
          "text": "Arrays exist",
          "flag": false
        },
        {
          "text": "Structs exist",
          "flag": false
        }
      ]
    },
    {
      "number": 16,
      "originalText": "Chapter 1\nIntroduction\nThe  modern  video  game  industry  is  large  and  diverse.   Game  developers  range\nin size from billion-dollar companies to individual hobbyists, and various games\nwill target all sorts of demographics.  One particular genre is the \"roguelike\", with\nfeatures  such  as  turn-based  combat,  permadeath,  and  the  procedural  generation\nof the levels’ layout maps.  With roots in the 1980 gameRogue, it continues to be\npopular to this day, with several large games having been released in recent years,\noften to wide critical praise.  On top of this, it maintains an active community of\nhobbyist and independent developers.\nChapter 2 explores the history and characteristics of the roguelike genre. It goes on\nto discuss the difficulties a developer might face when making roguelike games,\nespecially in regard to map generation. It details current solutions to this problem,\nbefore concluding that there is a space in the ecosystem for a domain-specific lan-\nguage to aid developers in procedurally generating content for roguelike games.\nThe  report  then  continues  to  chapter  3,  where  it  names  the  language  \"CARL:  A\nRoguelike Language\" (CARL), and discusses the various considerations that must\nbe made when designing this language.  After this, the MoSCoW model is used to\noutline which features the language may have, and how the development of these\nfeatures is to be prioritised.\nThe report then details the syntax and semantics of CARL in chapter 4, providing a\nContext-Free Grammar for the language’s syntax, describing the various semantic\nformation rules and the transition system, and concepts such as the Environment-\nStore Model.\n1",
      "claims": [
        {
          "text": "The modern video game industry is large and diverse.",
          "flag": false
        },
        {
          "text": "Game developers range in size from billion-dollar companies to individual hobbyists.",
          "flag": false
        },
        {
          "text": "Various games will target all sorts of demographics.",
          "flag": false
        },
        {
          "text": "Roguelike games have features such as turn-based combat, permadeath, and procedural generation of levels' layout maps.",
          "flag": false
        },
        {
          "text": "The roguelike genre has roots in the 1980 game Rogue.",
          "flag": false
        },
        {
          "text": "The roguelike genre is popular to this day, with several large games having been released in recent years, often to wide critical praise.",
          "flag": false
        },
        {
          "text": "There is an active community of hobbyist and independent developers.",
          "flag": false
        },
        {
          "text": "Chapter 2 explores the history and characteristics of the roguelike genre.",
          "flag": false
        },
        {
          "text": "Developers may face difficulties when making roguelike games, especially in regard to map generation.",
          "flag": false
        },
        {
          "text": "Current solutions exist for the problem of map generation in roguelike games.",
          "flag": false
        },
        {
          "text": "There is a space in the ecosystem for a domain-specific language to aid developers in procedurally generating content for roguelike games.",
          "flag": false
        },
        {
          "text": "The language CARL: A Roguelike Language (CARL) was designed for this purpose.",
          "flag": false
        },
        {
          "text": "Considerations must be made when designing CARL.",
          "flag": false
        },
        {
          "text": "The MoSCoW model is used to outline which features CARL may have, and how the development of these features is to be prioritised.",
          "flag": false
        },
        {
          "text": "CARL has a Context-Free Grammar for its syntax.",
          "flag": false
        },
        {
          "text": "Semantic formation rules exist in CARL.",
          "flag": false
        },
        {
          "text": "A transition system exists in CARL.",
          "flag": false
        },
        {
          "text": "The Environment-Store Model concept exists in CARL.",
          "flag": false
        }
      ]
    },
    {
      "number": 17,
      "originalText": "2Chapter 1.   Introduction\nThe reports then describes the implementation phase of CARL in Chapter 5, where\nit is determined that CARL would best be implemented through an interpreter, and\nthen discusses the decisions made and the steps taken to develop said interpreter.\nChapter 6 then describes how unit tests, integration tests, and acceptance tests were\nwritten for CARL’s interpreter.\nOnce the implementation has been completed, Chapter 7 evaluates the current state\nof  the  CARL  programming  language,  and  discusses  how  well  it  fits  the  criteria\noutlined earlier in the report. Finally, Chapter 8 discusses how the language could\nbe improved upon in the future,  with a focus on how the project’s criteria could\nhave been reached given more time.\nThe report uses this structure to document the development of CARL, from con-\nception  to  its  current  state.   Throughout  this,  the  project  showcases  the  team’s\nability to design, formally describe, and implement a purpose-built programming\nlanguage, in accordance with the project’s curriculum.",
      "claims": [
        {
          "text": "CARL would best be implemented through an interpreter",
          "flag": false
        },
        {
          "text": "the decisions made were taken to develop said interpreter",
          "flag": false
        },
        {
          "text": "unit tests, integration tests, and acceptance tests were written for CARL's interpreter",
          "flag": false
        }
      ]
    },
    {
      "number": 18,
      "originalText": "Chapter 2\nProblem analysis\nThis chapter delves into the essence and evolution of roguelike games, exploring\nthe genre and its random level generation.  The analysis will focus on defining the\nroguelike genre, starting with the origins of \"Rogue,\" a game that laid the ground-\nwork for the genre, and then exploring its evolution. The primary objective of this\nanalysis  is  to  investigate  how  technology  can  assist  indie  developers  in  creating\nmaps and content for roguelike games.  This will be accomplished by examining\nhow maps and content of roguelike games are generated using procedural gener-\nation algorithms.  Additionally, the analysis will explore current solutions, with a\nfocus on the utilization of libraries and game engines.\n3",
      "claims": []
    },
    {
      "number": 19,
      "originalText": "4Chapter 2.   Problem analysis\n2.1    The Roguelike genre\nRogue was a game released in 1980.  It was a game that did not have any graphics\nand  displayed  everything  as  text.   It  was  turn-based,  meaning  the  game  waited\nfor  you  to  make  an  input  before  anything  else  happened  in-game.  It  was  also  a\ndungeon crawler, meaning you walked through a dungeon fighting enemies and\ngetting loot to make you stronger throughout randomly generated levels.  It had\npermadeath, meaning if your character died, he was dead forever, and you needed\nto start over making you start over after every death, making it less forgiving.  In\nRogue, you needed to go from the top floor to the bottom to retrieve theAmulet of\nYendorand then go back to the top [39].\nRogue had algorithms for content creation, such as the generation of maps, which\nconsisted of tiles in a grid.  These tiles could be floors, walls, loot, chests, or Non-\nPlayable  Characters  (NPCs),  which  were  enemies  for  the  player  to  fight.   These\ngeneration algorithms have built-in capabilities to create content on the fly, ensur-\ning that every run is unique for the player. The health and strength of Rogue’s NPC\nenemies were hard-coded by the programmer according to the level the player was\non.\nFigure 2.1:Screenshot of Rogue gameplay\nThe  termRoguelikestarted  in  “Usenet  newsgroups”,  [40]similar  to  discussion  fo-\nrums. There was a need to refer to games similar to Rogue, Hack, Moria, Angband.\nIt was debated on those forums for several weeks until it was decided to name the\ngenre roguelike, as Rogue was the oldest [32]. The following points are the defining\ncharacteristics roguelike games, based on the International Roguelike Development",
      "claims": [
        {
          "text": "Rogue was a game released in 1980.",
          "flag": false
        },
        {
          "text": "It did not have any graphics and displayed everything as text.",
          "flag": false
        },
        {
          "text": "It was turn-based, meaning the game waited for you to make an input before anything else happened in-game.",
          "flag": false
        },
        {
          "text": "It was also a dungeon crawler, meaning you walked through a dungeon fighting enemies and getting loot to make you stronger throughout randomly generated levels.",
          "flag": false
        },
        {
          "text": "It had permadeath, meaning if your character died, he was dead forever, and you needed to start over making you start over after every death, making it less forgiving.",
          "flag": false
        },
        {
          "text": "You needed to go from the top floor to the bottom to retrieve the Amulet of Yendor and then go back to the top.",
          "flag": false
        },
        {
          "text": "Rogue had algorithms for content creation, such as the generation of maps, which consisted of tiles in a grid.",
          "flag": false
        },
        {
          "text": "These tiles could be floors, walls, loot, chests, or Non-Playable Characters (NPCs), which were enemies for the player to fight.",
          "flag": false
        },
        {
          "text": "These generation algorithms have built-in capabilities to create content on the fly, ensuring that every run is unique for the player.",
          "flag": false
        },
        {
          "text": "The health and strength of Rogue's NPC enemies were hard-coded by the programmer according to the level the player was on.",
          "flag": false
        },
        {
          "text": "The term 'Roguelike' started in 'Usenet newsgroups', similar to discussion forums.",
          "flag": false
        },
        {
          "text": "There was a need to refer to games similar to Rogue, Hack, Moria, Angband.",
          "flag": false
        },
        {
          "text": "It was debated on those forums for several weeks until it was decided to name the genre roguelike, as Rogue was the oldest.",
          "flag": false
        }
      ]
    },
    {
      "number": 20,
      "originalText": "2.1.   The Roguelike genre5\nConference 2008. It is referred to as the Berlin Interpretation[25]:\n•Random environment generation:  Maps are randomly generated on the fly\nin a way that increases replayability.\n•Permadeath:  If you die during the run, you start over, making a whole new\nrun and your previous character is forever lost.\n•Turn based:  The game is not sensitive to time, you can take your time to do\nan  action.  All  actions  take  the  same  amount  of  time.  Monsters  move  after\nyou finished your turn.\n•Grid  based:  Everything  is  a  tile,  monsters  take  place  as  a  singular  tile,  no\nmatter the monster’s size.\n•Non-modal: Every action should be available at all times\n•Complexity:  The game has many possible solutions.  There does not exist a\nsingular way to play the game.\n•Hack’n’slash: Killing a lot of enemies.\n•Exploration and discovery:  You know nothing and need to discover every-\nthing anew in every run.\nThese were decided to be high value factors for a game to be considered Roguelike.\nIn the start of the 2000s, new games were made that were inspired by Rogue and\nthe  roguelike  genre,  but  did  not  include  some  of  the  defining  characteristics  of\nwhat was considered \"roguelike\".  Some of the things that were new to this genre\nwere: post-death progression (unlocking more equipment you can get in new runs\nor  base  stats  increases  that  persists  through  runs),  and  elimination  of  top-down\n(bird eye view of the playing field), and turn based combat.\nThis has made the genre explode in popularity in recent years, for example Hades,\nwinning multiple awards [17] and receiving a 94% score on OpenCritic and 100%\nrecommended[22]. Another huge success is Dead Cells, with both Hades and some\nDownloadable Content (DLC) to Dead Cells being in the top 10 of the best rated\nopen critic pc games of all time.  [21] Some old fans of the genre disliked calling\nthem roguelikes[26].  They felt it was too different to the old roguelikes, and that\nmade it hard to know if the newly released games were something for them.  So",
      "claims": []
    },
    {
      "number": 21,
      "originalText": "6Chapter 2.   Problem analysis\nthere was a need to make a new term, which is how the termRoguelite/Roguelike-\nlikewas born. They are also sometimes calledAction Roguelikes.\nFigure 2.2:Gameplay [13]",
      "claims": []
    },
    {
      "number": 22,
      "originalText": "2.1.   The Roguelike genre7\nFigure 2.3:Typical map of the first level [8]\nIn the end, there is not an official definition, but the most official is the Berlin inter-\npretation2.1.  However, even that has only close to 1400 views on Google forums.\nThe entire genre is fan-defined, and the difference matters only to some hardcore\nenthusiastic fans, while most others are not as picky. However, one thing that they\nhave in common is procedural generated content [26].",
      "claims": []
    },
    {
      "number": 23,
      "originalText": "8Chapter 2.   Problem analysis\n2.2    Map generation and algorithms\nA big part of roguelike games is procedural map generation, which enables maps\nto be randomly created at runtime. This is achieved by utilising predefined objects\nand  structures  to  generate  randomized  maps  with  NPCs,  loot,  etc.,  resulting  in\neach  map  being  unique  [24].  After  creating  the  map,  the  NPC’s,  loot,  traps,  etc.\ncan be randomly placed within the map.  This can be seen in the game \"Rogue\",\nwhere  the  monsters  are  randomly  placed  on  the  floor  tiles,  by  looping  over  the\nfloor tiles until a valid floor tile is found [34].\nVarious methods for procedural map generation have been established, involving\nalgorithms that allow for map creation based on specific parameters [24].  An ex-\nample of a procedural map generation algorithm is the Random Walk algorithm.\nIt  works  by  carving  out  the  map  by  randomly  selecting  tiles  neighbouring  tiles\nto the current location, and marking the explored area until a certain area size is\nexplored.   The  algorithm  initialises  a  grid,  marking  all  tiles  as  walls,  and  selects\na random starting position within a defined area.  It marks visited tiles as floors\nwhile traversing.  The algorithm iterates a set number of steps, checking each step\nfor valid movement  within the grid bounds.  Upon finding a  valid movement,  it\nmarks the corresponding tile as a floor and updates the current position, proceed-\ning to explore the next tile [30].\nFigure 2.4:Example of a Random Walk generated map [30]",
      "claims": [
        {
          "text": "Map generation enables maps to be randomly created at runtime.",
          "flag": false
        },
        {
          "text": "Predefined objects and structures can be used to generate randomized maps with NPCs, loot, etc.",
          "flag": false
        },
        {
          "text": "Each map is unique.",
          "flag": false
        },
        {
          "text": "NPCs, loot, traps, etc. can be randomly placed within the map after creating it.",
          "flag": false
        },
        {
          "text": "Monsters are randomly placed on floor tiles in the game 'Rogue' by looping over the floor tiles until a valid floor tile is found.",
          "flag": false
        },
        {
          "text": "Various methods for procedural map generation have been established.",
          "flag": false
        },
        {
          "text": "Algorithms allow for map creation based on specific parameters.",
          "flag": false
        },
        {
          "text": "The Random Walk algorithm is an example of a procedural map generation algorithm.",
          "flag": false
        },
        {
          "text": "The Random Walk algorithm works by carving out the map by randomly selecting tiles neighbouring tiles to the current location, and marking the explored area until a certain area size is explored.",
          "flag": false
        },
        {
          "text": "The algorithm initialises a grid, marking all tiles as walls, and selects a random starting position within a defined area.",
          "flag": false
        },
        {
          "text": "Visited tiles are marked as floors while traversing.",
          "flag": false
        },
        {
          "text": "The algorithm iterates a set number of steps, checking each step for valid movement within the grid bounds.",
          "flag": false
        },
        {
          "text": "Upon finding a valid movement, it marks the corresponding tile as a floor and updates the current position, proceeding to explore the next tile.",
          "flag": false
        }
      ]
    },
    {
      "number": 24,
      "originalText": "2.2.   Map generation and algorithms9\nAnother algorithm, cellular automata, works by creating a randomised map, then\niterating over each tile to check if the current tile and neighbouring tiles are walls,\nand then turning it either into a wall or a floor. The algorithm begins by generating\na randomised map using a noise algorithm.  Once the original map is created, the\ncellular automata algorithm iterates over it to create a new map.  It processes all\nthe  tiles,  examining  the  neighbours  of  the  tiles  that  are  walls.   If  four  or  more\nneighbouring  tiles  are  walls,  or  if  zero  neighbouring  tiles  are  walls,  it  will  then\nbecome  a  wall,  otherwise,  it  will  become  a  floor.   This  process  can  be  repeated\nbased on the desired map [41].\nFigure 2.5:Example of a Cellular Automata generated map [41]\nDifferent algorithms can be employed for various scenarios, depending on the de-\nsired  type  of  map,  and  are  typically  implemented  in  general-purpose  languages\n(GPL) such as C#, Java, Python, etc.  These languages are used to address general-\npurpose  problems,  and  implementing  these  maps  and  their  content  can  thus  re-\nquire  many  lines  of  code.   For  instance,  the  game  \"Rogue\"  is  written  in  C,  and\nconsists  of  hundreds  of  lines  of  code  dedicated  solely  to  creating  the  maps  and\ntheir content [34].\nAnother  approach  could  involve  domain-specific  languages  (DSLs).   These  lan-\nguages are highly specialised and assist developers in specific tasks, examples of\nthese include CSS and SQL. While GPLs can be complex and more challenging to\ncomprehend,  DSLs  could  offer  a  higher  level  of  abstraction,  making  them  easier",
      "claims": [
        {
          "text": "Cellular automata works by creating a randomised map",
          "flag": false
        },
        {
          "text": "The algorithm begins by generating a randomised map using a noise algorithm.",
          "flag": false
        },
        {
          "text": "Cellular automata algorithm iterates over it to create a new map.",
          "flag": false
        },
        {
          "text": "It processes all the tiles, examining the neighbours of the tiles that are walls.",
          "flag": false
        },
        {
          "text": "If four or more neighbouring tiles are walls, or if zero neighbouring tiles are walls, it will then become a wall, otherwise, it will become a floor.",
          "flag": false
        },
        {
          "text": "This process can be repeated based on the desired map",
          "flag": false
        },
        {
          "text": "Different algorithms can be employed for various scenarios, depending on the desired type of map",
          "flag": false
        },
        {
          "text": "Algorithms are typically implemented in general-purpose languages (GPL) such as C#, Java, Python, etc.",
          "flag": false
        },
        {
          "text": "These languages are used to address general-purpose problems, and implementing these maps and their content can thus require many lines of code.",
          "flag": false
        },
        {
          "text": "The game 'Rogue' is written in C, and consists of hundreds of lines of code dedicated solely to creating the maps and their content",
          "flag": false
        },
        {
          "text": "Another approach could involve domain-specific languages (DSLs)",
          "flag": false
        },
        {
          "text": "DSLs are highly specialised and assist developers in specific tasks",
          "flag": false
        },
        {
          "text": "Examples of these include CSS and SQL",
          "flag": false
        },
        {
          "text": "While GPLs can be complex and more challenging to comprehend, DSLs could offer a higher level of abstraction, making them easier",
          "flag": false
        }
      ]
    },
    {
      "number": 25,
      "originalText": "10Chapter 2.   Problem analysis\nto understand for both developers and non-developers [23].  Given that roguelike\ngames are a specialised area where much of the development follows similar ap-\nproaches,  adopting  a  domain-specific  language  could  mitigate  the  complexity  of\ncreating these types of games. However, it seems all current solutions use general-\npurpose languages and libraries to create maps and content for roguelike games.",
      "claims": [
        {
          "text": "adapting a domain-specific language could mitigate the complexity of creating these types of games.",
          "flag": false
        },
        {
          "text": "all current solutions use general-purpose languages and libraries to create maps and content for roguelike games",
          "flag": false
        }
      ]
    },
    {
      "number": 26,
      "originalText": "2.3.   Current solutions11\n2.3    Current solutions\nAs developing roguelikes is a relatively popular project for developers, and because\nroguelikes share many basic features, it makes sense that there already exist many\nsolutions that share this project’s goal of simplifying roguelike development. These\nprimarily exist in the forms of software libraries for general-purpose programming\nlanguages, but there exists at least one game engine specialised for roguelikes.\n2.3.1    Libraries\nThere are several libraries built with the aim of making the development of rogue-\nlike games easier.\nA  more  popular  library  to  use  islibtcod[5],  with  over  800  stars  on  GitHub.   It\ncontains tools for creating height maps,  generating random noise,  calculating an\nentity’s field of view, and other functions useful for the development of roguelikes.\nIt  is  primarily  written  in  C  and  C++,  but  can  also  be  used  in  Python  using  the\npython-tcodlibrary [6]. The library has several tools that help with map generation,\nsuch as their BSP Toolkit for handling Binary Space Partition trees (useful in some\nmap  generation  algorithms),  and  functions  for  generating  Bresenham  lines.   The\nnoise  functions  can  generate  Simplex,  Perlin,  and  Wavelet  noises  in  up  to  four\ndimensions.\nThe tutorial forpython-tcod[4] offers a simple example of how to generate a dun-\ngeon:\n1def  generate_dungeon(\n2max_rooms: int ,\n3room_min_size: int ,\n4room_max_size: int ,\n5map_width: int ,\n6map_height: int ,\n7engine: game.engine.Engine ,\n8) -> game.game_map.GameMap:\n9\"\"\" Generate a new  dungeon  map.\"\"\"\n10dungeon = game.game_map.GameMap(engine , map_width , map_height)\n11\n12rooms: List[RectangularRoom] = []\nThe code loops a specified number of times, each time generating a room’s width,\nheight, and position, based on a simple random number generator:\n1for _ in range(max_rooms):\n2room_width = engine.rng.randint(room_min_size , room_max_size)\n3room_height = engine.rng.randint(room_min_size , room_max_size)\n4",
      "claims": []
    },
    {
      "number": 27,
      "originalText": "12Chapter 2.   Problem analysis\n5x = engine.rng.randint(0, dungeon.width - room_width  - 1)\n6y = engine.rng.randint(0, dungeon.height  - room_height  - 1)\n7\n8# \"RectangularRoom\" class  makes  rectangles  easier  to work  with.\n9new_room = RectangularRoom(x, y, room_width , room_height)\nAfter generating these attributes, it runs through the previously generated rooms,\nand checks if any would intersect with this new one.  If any do, the program gives\nup on that room and tries generating a new one:\n1# Run  through  the  other  rooms  and see if they  intersect  with  this\none.\n2if any(new_room.intersects(other_room) for  other_room  in rooms):\n3continue   # This  room  intersects , so go to the  next  attempt.\n4# If  there  are no  intersections  then  the  room is  valid.\nThe code continues (if there are no intersecting rooms) by digging out the room. If\nthere are no previous rooms, it designates the centre of the new room as the level’s\nentry point.  Otherwise, it digs a tunnel from the previously generated room, and\nadds the room to the room list.\n1# Dig  out  this  rooms  inner  area.\n2dungeon.tiles[new_room.inner] = FLOOR\n3\n4if len(rooms) == 0:\n5# The  first  room , where  the  player  starts.\n6dungeon.enter_xy = new_room.center\n7else:   # All  rooms  after  the  first.\n8# Dig  out a tunnel  between  this  room  and the  previous  one.\n9for x, y in  tunnel_between(engine , rooms [-1].center , new_room.\ncenter):\n10dungeon.tiles[x, y] = FLOOR\n11\n12# Finally , append  the  new  room to the  list.\n13rooms.append(new_room)\nFinally, outside the loop, the function returns the dungeon that it has made.\n1return  dungeon\nThetunnel_between()function used above for generating L-shaped (Figure 2.6)\ntunnels between two points is not part of the toolkit, but is defined earlier in the\ntutorial.  Its code can be seen in listing 2.1.  It useslibtcod’s random number gener-\nator for deciding which direction the tunnel should face, andlibtcod’s Bresenham\nline generator to find the tiles in such a tunnel.  Bresenham’s line algorithm is an\nalgorithm for finding the most direct route between two points on a grid,  and is\nused for drawing \"straight\" lines on a grid [31].",
      "claims": []
    },
    {
      "number": 28,
      "originalText": "2.3.   Current solutions13\nFigure 2.6:An L-shaped tunnel between two square rooms\n1def  tunnel_between(\n2engine: game.engine.Engine , start: Tuple[int , int], end: Tuple[int\n, int]\n3) -> Iterator[Tuple[int , int ]]:\n4\"\"\" Return  an L-shaped  tunnel  between  these  two  points.\"\"\"\n5x1 , y1 = start\n6x2 , y2 = end\n7if  engine.rng.random () < 0.5:   # 50%  chance.\n8corner_x , corner_y = x2, y1   # Move  horizontally , then\nvertically.\n9else:\n10corner_x , corner_y = x1, y2   # Move  vertically , then\nhorizontally.\n11\n12# Generate  the  coordinates  for  this  tunnel.\n13for x, y in tcod.los.bresenham ((x1 , y1), (corner_x , corner_y)).\ntolist ():\n14yield x, y\n15for x, y in tcod.los.bresenham ((corner_x , corner_y), (x2, y2)).\ntolist ():\n16yield x, y\nListing 2.1:Code to generate L-shaped tunnels between two points, taken fromlibtcod’s tutorial[4]\nIt is clear that the burden of programming the map generation is set on the game\ndeveloper, withlibtcod’s only contribution being the Bresenham line generator. The\nprogrammer is expected to understand how map generation works and then im-\nplement it themselves, which may be overwhelming for some. As previously men-\ntioned,libtcoddoes offer tools to work with BSP’s, but that is not very useful for a\nprogrammer who doesn’t know what a BSP is, let alone how to make a roguelike\nmap with one.\nThere exist other libraries and toolkits, similar tolibtcod.  These may have a focus\non education (such asbracket-lib[42]) or target other platforms (such asrot.jsfor\nbrowser environments [44]).",
      "claims": []
    },
    {
      "number": 29,
      "originalText": "14Chapter 2.   Problem analysis\n2.3.2    The Role of Libraries in Roguelike Development\nThe  utilisation  of  the  mentioned  libraries,  is  important  in  the  development  of\nroguelike games.  These libraries help developers by giving them access to func-\ntionalities, including but not limited to map generation, noise generation, and cal-\nculations for the field of view.\nThe presence of large and active communities on Reddit, such as r/roguelikedev,\nr/howdidtheycodeit,  and  r/gamedev,  which  are  centred  around  the  manual  cre-\nation and sharing of development techniques, underscores the lack of comprehen-\nsive, ready-made solutions for roguelike game map generation. While libraries ex-\nist that can aid in development, they often fall short of the flexibility and specificity\noffered by custom-built algorithms. This reliance on community-driven knowledge\nexchange  and  custom  algorithm  development  highlights  the  possible  scarcity  of\nout-of-the-box tools tailored for roguelike development.\n2.3.3    Game Engines\nGame  Engines  are  often  used  by  developers  to  simplify  various  parts  of  game\ndevelopment, such as graphics, audio, and input[10].\nA popular general-purpose game engine, that can be used for developing rogue-\nlikes, isUnity.  One of the official tutorial projects is the development of a rogue-\nlike game, which is listed as \"Intermediate\" difficulty [37].  AsUnityis a general-\npurpose game engine,  it does not offer functions for randomly generating maps,\nand this functionality has to be implemented by the developer themselves.\nAnother  game  engine  is  T-Engine  4,  built  in  Lua.   It  is  specialised  for  roguelike\ndevelopment [12]. While it was originally developed for the gameTales of Maj’Eyal,\nit is available standalone and has been used by other games.\nOn  top  of  helping  with  graphics  and  sound,  it  claims  to  offer  features  for  han-\ndling maps and generating characters.  It offers several interfaces that games can\nimplement, including\nengine.generator.map.RoomsLoader[11], that can be used\nto define a generator for a dungeon.  An example of code that uses this interface\ncan be found on GitHub.",
      "claims": []
    },
    {
      "number": 30,
      "originalText": "2.4.   Target audience15\n2.4    Target audience\nRoguelike games, their algorithms, and their content are typically coded in general-\npurpose  languages.   To  achieve  this,  libraries  and  game  engines  can  be  used  to\nminimize the amount of time and resources spent on creating these games.  How-\never,  this  would  still  require  developers  to  be  familiar  with  the  general-purpose\nlanguage, the libraries, and the game engines.\nWithin the project scope, two notable target groups are indie developers and AAA\ndevelopers.   However,  considering  the  resources  and  expertise  in  game  develop-\nment  typically  found  in  the  latter  group,  the  report’s  focus  will  be  narrowed  to\nindie developers. Indie developers may lack experience in game development, and\nmight have fewer resources or less time available. They might not have the knowl-\nedge about how to write algorithms for procedural map generations, or if they do,\nthey might not have the time to research the various ones and implement relevant\nones [43].\nGiven  the  lack  of  ready-made  solutions  for  roguelike  development,  many  devel-\nopers are likely custom-building content generation algorithms.  The communities\nsurrounding  roguelike  game  development  such  as  r/roguelikedev,  r/howdidth-\neycodeit,  and  r/gamedev,  further  support  the  continuation  of  this  practice.   As\nmentioned,  knowledge in general-purpose language becomes a necessity.  There-\nfore, creating a domain-specific language could simplify the development process,\nmaking programming accessible to indie developers without an extensive techni-\ncal background.  Creating a domain-specific language can bridge the gap between\ncomplex coding requirements and indie developers’ limited coding expertise.",
      "claims": []
    },
    {
      "number": 31,
      "originalText": "16Chapter 2.   Problem analysis\n2.5    Problem definition\nMap algorithms for Roguelike games are in general made from the bottom up by\nindie game developers.  Indie developers do not have a lot of resources, and have\nto program the maps and content themselves.  There exist libraries and other tool-\ning to support the developer with map generation to some extent, but they do not\nprovide enough support for inexperienced developers.  This means that the indie\ndevelopers have to dedicate a lot of time implementing algorithms that otherwise\ncould  be  spent  on  other  aspects  of  their  game.   Additionally,  Roguelike  games\nare often made in general purpose languages.  These languages were not specifi-\ncally tailored to support the development of Roguelike map generation games.  A\ndomain-specific language with a focus on implementing Roguelike map generation\ncould therefore help the indie developers with implementing parts of their game.\nHow can a domain-specific programming language be designed,\nimplemented and tested to support indie developers\nin creating procedurally generated Roguelike content?",
      "claims": []
    },
    {
      "number": 32,
      "originalText": "Chapter 3\nRequirements\nIn  the  analysis,  it  was  highlighted  that  there  is  potential  for  a  Domain-specific\nlanguage to be developed specifically for map generation.  The project will hereby\nfocus on the development of this language, which shall be named \"CARL: A Rogue-\nlike Language\", or \"CARL\" for short.\nThe following chapter will focus on the design phase of the development of CARL.\nIn this phase, the language’s guidelines, and the reasoning for those choices will be\noutlined.  This will also give a better common understanding of how the language\ndesign should be designed and then implemented.\n17",
      "claims": [
        {
          "text": "there is potential for a Domain-specific language to be developed specifically for map generation.",
          "flag": false
        },
        {
          "text": "the project will focus on the development of this language",
          "flag": false
        },
        {
          "text": "the language shall be named 'CARL: A Rogue-like Language'",
          "flag": false
        },
        {
          "text": "the language shall be named 'CARL' for short",
          "flag": false
        }
      ]
    },
    {
      "number": 33,
      "originalText": "18Chapter 3.   Requirements\n3.1    Prototype\nBefore designing the language, it is crucial to have a clear goal of how the program\nshould be used, and what its expected output will be. This section will demonstrate\na potential output for a program written in CARL. And how it would be displayed\nin a game engine such as Unity.  By examining how the output could appear and\nfunction beforehand, it ensures that there is a clear objective for how the custom\nlanguage should operate.\nListing 3.1 illustrates the potential output after writing and compiling in the lan-\nguage CARL. Another approach was experimented with, to illustrate the map lay-\nout using double nested array, but after some experimentation, it was found that\nthe Unity game engine does not support this functionality in its default library.  If\nsomebody  wanted  to  load  the  file,  they  would  need  to  import  the  \".NET\"  JSON\nparsing  library,  which  makes  it  more  inconvenient  than  just  to  use  the  standard\nlibrary.\n1{\n2\"map\": {\n3\"size\": {\n4\"height\": 10,\n5\"width\": 10\n6},\n7\"tiles\": [\n8{\"row\": [\"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\"]},\n9{\"row\": [\"w\", \"f\", \"f\", \"f\", \"w\", \"f\", \"f\", \"f\", \"f\", \"w\"]},\n10{\"row\": [\"w\", \"f\", \"w\", \"f\", \"f\", \"f\", \"w\", \"w\", \"f\", \"w\"]},\n11{\"row\": [\"w\", \"f\", \"w\", \"w\", \"w\", \"f\", \"w\", \"f\", \"f\", \"w\"]},\n12{\"row\": [\"w\", \"f\", \"f\", \"f\", \"w\", \"f\", \"f\", \"f\", \"w\", \"w\"]},\n13{\"row\": [\"w\", \"w\", \"w\", \"f\", \"f\", \"f\", \"w\", \"f\", \"f\", \"w\"]},\n14{\"row\": [\"w\", \"f\", \"f\", \"f\", \"w\", \"f\", \"w\", \"f\", \"w\", \"w\"]},\n15{\"row\": [\"w\", \"f\", \"w\", \"f\", \"f\", \"f\", \"f\", \"f\", \"w\", \"w\"]},\n16{\"row\": [\"w\", \"f\", \"p\", \"f\", \"w\", \"w\", \"w\", \"f\", \"f\", \"w\"]},\n17{\"row\": [\"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\"]}\n18],\n19\"level\": 1,\n20\"type\": \"Room\",\n21\"tileInformation\": [\n22{\n23\"tile\": \"w\",\n24\"info\": {\n25\"name\": \"Wall\",\n26\"baseInformation\": {\n27\"solid\": true\n28}\n29}\n30},\n31{",
      "claims": []
    },
    {
      "number": 34,
      "originalText": "3.1.   Prototype19\n32\"tile\": \"f\",\n33\"info\": {\n34\"name\": \"Floor\",\n35\"baseInformation\": {\n36\"solid\": false\n37}\n38}\n39},\n40{\n41\"tile\": \"p\",\n42\"info\": {\n43\"name\": \"Player\",\n44\"baseInformation\": {\n45\"solid\": false\n46}\n47}\n48}\n49]\n50}\n51}\nListing 3.1:JSON file of a map\nThe provided JSON object in Listing 3.1 represents a game map, detailing its layout,\nsize,  and  the  properties  of  different  tiles  (e.g.,  walls,  floor,  player).   The  map  is\ndefined by a grid of tiles, with each tile type represented by a letter (e.g., \"w\" for\nwall, \"f\" for floor, \"p\" for player).  Each tile type’s properties, such as whether it is\nsolid,  are described in the tileInformation section.  This structure allows for easy\nupdates  and  additions  to  the  game  environment  without  editing  the  core  game\ncode.\nThe idea behind the map is to be able to have a somewhat graphical way to rep-\nresent the map, without needing to render or display it first in a game engine.  It\nalso allows for easy understanding on how the file should be parsed, by giving the\nobvious clue on how it is laid out.\nFigure  3.1  shows  how  the  game  looks  when  the  game  renders  the  JSON  into  a\nplayable map.",
      "claims": []
    },
    {
      "number": 35,
      "originalText": "20Chapter 3.   Requirements\nFigure 3.1:How the game looks after rendering the data from JSON file\nEach tile is changed to what it should be, wherewis a wall tile,fis a floor tile,\nand\npis the player.  Besides spawning a player there, the game also places a floor\ntile below them.  For this screenshot,  the player was moved to the middle of the\nmap so that the entire map could be visible.\nThe prototype specifies the concrete functionalities that CARL must support, which\nwill be taken into consideration when defining the criteria.",
      "claims": []
    },
    {
      "number": 36,
      "originalText": "3.2.   Criteria for Programming Languages21\n3.2    Criteria for Programming Languages\nIn programming, the effectiveness of a language is often evaluated by specific crite-\nria that reflect its usability for developers. The criteria, readability, writability, and\nreliability  are  fundamental  for  evaluating  a  programming  language,  and  under-\nstanding how various language characteristics impact these criteria is important.\nThis  section  follows  the  definitions  written  in  \"Concepts  of  Programming  Lan-\nguages\" by Robert W. Sebesta [33], which describes the definitions of the criteria.\nThis can be used to greatly improve the common understanding of the language\ndesign.\nFigure 3.2:Criteria for a programming language from Robert W. Sebest [33]\n3.2.1    Readability, Writeability and reliability\nIn Table 3.2 one can see, what characteristics impact, what criteria.  Readability is\nabout  how  easily  code  can  be  understood,  making  it  easier  to  read  and  modify.\nWritability  refers  to  the  ease  with  which  developers  can  write  code,  and  create\nprograms to solve a problem in a specific domain using the given language.  It is\na crucial factor in determining the efficiency of problem-solving in software devel-\nopment.  Reliability refers to how well a programming language helps developers\ncreate programs that run correctly under all conditions.  Specific criteria were pri-\noritized for the focus of this project and will be elaborated on in this section, while\nother criteria have been outlined in the appendix.A\nSimplicity\nA  language  with  many  constructs  may  be  more  challenging  to  fully  learn  and\ncomprehend. Additionally, having multiple ways to achieve the same task can also",
      "claims": [
        {
          "text": "The effectiveness of a programming language is often evaluated by specific criteria that reflect its usability for developers.",
          "flag": false
        },
        {
          "text": "Readability is about how easily code can be understood, making it easier to read and modify.",
          "flag": false
        },
        {
          "text": "Writeability refers to the ease with which developers can write code and create programs to solve a problem in a specific domain using the given language.",
          "flag": false
        },
        {
          "text": "Reliability refers to how well a programming language helps developers create programs that run correctly under all conditions.",
          "flag": false
        },
        {
          "text": "A language with many constructs may be more challenging to fully learn and comprehend.",
          "flag": false
        },
        {
          "text": "Having multiple ways to achieve the same task can also make it harder to learn and use the language.",
          "flag": false
        }
      ]
    },
    {
      "number": 37,
      "originalText": "22Chapter 3.   Requirements\nhinder the readability of the language[33].  Listings 3.3 and 3.2 show examples of\na for loop in Python and emu8086 assembly,  respectively.  In both examples,  the\ncode loops four times.\n1\n2xor cx,cx    ; cx -register  is the  counter , set to 0\n3loop1    nop           ; Replace \"nop\" with  the  loop  body.  The  loop  body\nshould  not  change  cx\n4inc cx       ; Increment\n5cmp cx ,3     ; Compare  cx to 3, one  less  than  the  desired\nnumber  of  iterations\n6jle  loop1    ; Loop  while  less or equal (to 3)\nListing 3.2:8086 assembler loop[35].\nIn contrast, Python offers a much simpler and more readable way to perform loops:\n1for _ in range (4):\n2pass   #Replace  this  with  the  loop  body\nListing 3.3:Python for loop\nCARL is made for indie developers, and one of the aims of the language is to make\nit simpler for the roguelike game developer to implement their maps.  Therefore,\nsimplicity  of  their  implementations  is  one  of  the  focus  points.   This  should  help\nwith readability and write ability.\nOrthogonality\nOrthogonality in programming refers to the ability to use language features con-\nsistently and predictably across different contexts.  For instance, a language is or-\nthogonal when it enables functions to accept any data type as parameters.[33]\nListing  3.4  shows  an  example  of  Python,  a  language  with  high  orthogonality.  A\nfunction  calledprocessis  defined,  with  a  single  parameter.   Then,  that  function\nis  called  with  an  integer,  a  floating-point  number,  and  a  string,  respectively,  as\narguments.  Despite the variety in data types,  the code runs as expected without\nerrors.\n1def  process(data):\n2print(data)\n3\n4process (123)\n5process (45.67)\n6process(\"text\")\nListing 3.4:Different data types in python",
      "claims": [
        {
          "text": "hinder the readability of the language",
          "flag": false
        },
        {
          "text": "the code loops four times",
          "flag": false
        },
        {
          "text": "Python offers a much simpler and more readable way to perform loops",
          "flag": false
        },
        {
          "text": "CARL is made for indie developers",
          "flag": false
        },
        {
          "text": "one of the aims of the language is to make it simpler for the roguelike game developer to implement their maps",
          "flag": false
        },
        {
          "text": "simplicity of their implementations is one of the focus points",
          "flag": false
        },
        {
          "text": "Orthogonality in programming refers to the ability to use language features consistently and predictably across different contexts",
          "flag": false
        },
        {
          "text": "a language is orthogonal when it enables functions to accept any data type as parameters",
          "flag": false
        }
      ]
    },
    {
      "number": 38,
      "originalText": "3.2.   Criteria for Programming Languages23\nIn the language CARL, Orthogonality should be weighted one to the extent that\nthe language should support simple operations between similar data types, such\nas adding integers to floats, while also limiting the scope of orthogonality to not\nallow  operations  such  as  adding  integers  to  strings.   This  focus  should  help  the\ndeveloper with writeability, and also it should ensure some structural consistency\nand therefore act more reliably as the coder intended.\nData Types\nWell-defined and diverse data types enable the reader to grip what kind of data is\nbeing manipulated[33].  For example,  using adatetimetype instead of a string to\nhandle dates makes the intention clearer, as demonstrated in listings 3.5 and 3.6.\nAdditionally, precise data types could allow for more standardised manipulation\nof this data, for example through the use of methods.\n1from  datetime  import  datetime\n2meeting_date = datetime (2024 , 3, 11, 14, 30)\n3print(\"Meeting  Date:\", meeting_date)\nListing 3.5:Clear datatypes in python\n1meeting_date = \"2024 -03 -11  14:30\"\n2print(\"Meeting  Date:\", meeting_date)\nListing 3.6:Generic data types in python\nCARL has specific data types, including some of the primitive ones like integers,\nstrings,  and  floats,  and  non-primitive  specialised  data  types  designed  for  tasks\nsuch as map generation. These more specialised data types should help with write-\nability and readability.  These specific data types could assist the programmer in\nunderstanding the kind of data they are handling, and thereby help with reliability.\nFor example, by enforcing data type restrictions, a system could catch operations\nunsuitable for given data types, like adding a number to a string at compile time.\nSyntax Design\nThe  use  of  language  elements,  such  as  reserved  keywords  (if,  else,  while,  print)\nand their formatting, can impact the readability of a language[33].\n1if  temperature  > 100:\n2print(\"It’s too hot!\")\n3else:\n4print(\"It’s comfortable.\")\nListing 3.7:Example of Syntax Design in python",
      "claims": []
    },
    {
      "number": 39,
      "originalText": "24Chapter 3.   Requirements\nListing 3.7 illustrates Python’s syntax design, using straightforward use of condi-\ntionals  and  print  statements,  making  the  code’s  purpose  apparent.   This  can  be\nharder to read in Listing 3.8 with the C++ code usingstd::coutand its use of<<to\nprint text.\n1#include  <iostream >\n2\n3int  main() {\n4int  temperature = 105; //  Example  temperature\n5if (temperature  > 100) {\n6std::cout  << \"It’s too  hot!\" << std::endl;\n7} else {\n8std::cout  << \"It’s comfortable.\" << std::endl;\n9}\n10return  0;\n11}\nListing 3.8:Unintuitive syntax in C++\nThe team also chose to make reserved keywords, such as\nvar(short for variable)\nwhen creating variables orwhilewhen creating while loops, which was done in\norder to make CARL more intuitive.  This should improve CARL’s readability and\nwritability, as the code clearly expresses its function and has familiarity with other\nwell-known languages.\nSupport for abstraction\nAbstraction involves concealing complexity within constructs like functions, classes,\nor modules,  which allow developers to focus on higher level concepts instead of\nfocusing on detailed implementation [33].  Languages with enhanced abstraction\ncapabilities  facilitate  the  expression  of  complex  ideas  in  a  more  concise  and  un-\nderstandable  manner.   For  example,  the  code  snippet  below  demonstrates  how\nJava employs builtin functions for abstraction, allowing functionality encapsulated\nactions behind simple function calls.\n1List <Integer > numbers = Arrays.asList(5, 3, 8, 1, 9, 2);\n2// Using  built -in  function  to find  the  maximum  element  instead\nof loop\n3int  maxNumber = Collections.max(numbers);\nListing 3.9:Interfaces for encapsulating complex behaviors in Java\nThe last of these focuses of CARL is to simplify the implementation of map gener-\nation, by supporting abstraction.  It allows for creating more complex operations,\nsuch  as  invoking  ‘createMap.someAlgorithm‘  to  generate  a  map  using  a  specific\nalgorithm.  This capability not only simplifies the coding process by encapsulating",
      "claims": [
        {
          "text": "Python's syntax design is straightforward and easy to read",
          "flag": false
        },
        {
          "text": "C++ code using std::cout and its use of << to print text can be harder to read",
          "flag": false
        },
        {
          "text": "The team chose reserved keywords such as var (short for variable) when creating variables or while when creating while loops to make CARL more intuitive",
          "flag": false
        },
        {
          "text": "This should improve CARL's readability and writability",
          "flag": false
        },
        {
          "text": "Abstraction involves concealing complexity within constructs like functions, classes, or modules",
          "flag": false
        },
        {
          "text": "Languages with enhanced abstraction capabilities facilitate the expression of complex ideas in a more concise and understandable manner",
          "flag": false
        },
        {
          "text": "Java employs built-in functions for abstraction, allowing functionality encapsulated actions behind simple function calls",
          "flag": false
        },
        {
          "text": "The code snippet below demonstrates how Java employs built-in functions for abstraction",
          "flag": false
        },
        {
          "text": "CARL simplifies the implementation of map generation by supporting abstraction",
          "flag": false
        },
        {
          "text": "It allows for creating more complex operations, such as invoking 'createMap.someAlgorithm' to generate a map using a specific algorithm",
          "flag": false
        }
      ]
    },
    {
      "number": 40,
      "originalText": "3.2.   Criteria for Programming Languages25\ncomplex logic behind simpler interfaces but also enhances readability by allowing\ndevelopers to focus on the higher-level logic of their applications without getting\nbogged down in the details of implementation.\nSummary of criteria\nThese  criteria  should  help  the  team  outline  the  guidelines  of  what  is  important,\nwhen it comes to designing the programming language.  It also helped the team’s\ncommon understanding, and should assist in outlining the MoSCoW requirements\nfor this programming language.",
      "claims": [
        {
          "text": "complex logic can be behind simpler interfaces",
          "flag": false
        },
        {
          "text": "readability is enhanced by allowing developers to focus on higher-level logic",
          "flag": false
        }
      ]
    },
    {
      "number": 41,
      "originalText": "26Chapter 3.   Requirements\n3.3    MoSCoW requirements\nThe MoSCoW method is a model for prioritising a project’s requirements. It places\nrequirements into four groups [7]:\n•Must have, for the minimum requirements that must be fulfilled by the project\nto accomplish its goal.\n•Should have, for requirements that are important for the project to be consid-\nered complete, but the system would still be usable without.\n•Could have, for additional requirements that would increase the quality of the\nproject.\n•Will not have,  for  requirements  that  will  not  be  fulfilled  during  the  project,\nas they have been judged to be too time-consuming or complex to be worth\nimplementing.  Ideas completely irrelevant to the problem statement are not\nincluded.\nTheMust haverequirements define the Minimum Viable Product (MVP). The MVP\nis the minimum set of features required for the system to be accepted, providing\nan output just enough to fulfil its purpose [7].\nThemust haverequirements are not in any specific order, but theshould haveand\ncould haverequirements are listed in order of priority.\n3.3.1    Must Have\nMMust have\nM1The language must support data creation/management\nM2The  program  must  allow  the  data  to  be  written  to  a  file  in  a  serialised\nformat, such as JSON, XML, or CSV\nM3The language must contain at least one predefined algorithm for generat-\ning the outline of a level, walls and floors\nM4The  language  must  support  the  ability  to  write  and  use  custom  level-\ngeneration algorithms\nM5Language must support the procedural placement of objects.\nTable 3.1:Must haves",
      "claims": []
    },
    {
      "number": 42,
      "originalText": "3.3.   MoSCoW requirements27\nM1 Data Structure Creation and Management\nThe language must enable developers to define and manipulate custom data struc-\ntures,  which  will  include  structs  and  arrays.  It’s  crucial  for  organising  and  han-\ndling the various components involved in level generation, like tile maps, enemy\nconfigurations, and item placements.\nM2 serialisation for Data Storage\nThe language must allow for the functionality to write data to a file, and serialise\nthe  data  into  at  least  one  widely  recognized  data  storage  format,  such  as  JSON,\nXML, or CSV. This capability is vital for exporting the generated levels in a format\nthat can be easily interpreted by other programs or game engines like Unity and\nUnreal Engine.\nM3 Predefined Level Generation Algorithms\nThe  language  must  come  equipped  with  at  least  one  built-in  algorithm  for  level\ngeneration.   This  predefined  algorithm  serves  as  a  starting  point  for  developers,\nenabling them to quickly generate the outline of levels without the need to write\ncomplex algorithms from scratch.\nM4 Custom Level-generation Algorithms\nThe language must be flexible enough to allow developers to write and implement\ntheir  own  level  generation  algorithms.   This  adaptability  would  support  a  wide\nrange of games, providing the tools to create the level generation algorithm to the\nuser’s specific needs.\nM5 Support for Procedural Object placement\nThe language must include features that support the placement of random objects\nwithin the levels. This capability is critical for creating dynamic and unpredictable\ngame  environments.   Specifically,  it  should  allow  for  the  random  placement  of\ncustom objects defined by the user. An example of this could be Enemies, Loot, or\nObstacles.",
      "claims": []
    },
    {
      "number": 43,
      "originalText": "28Chapter 3.   Requirements\n3.3.2    Should Have\nSShould have\nS1The  language  should  be  able  to  alter  its  generation  based  on  parameters\nsuch as level or desired difficulty\nS2The  language  should  be  able  to  randomly  generate  values  for  properties\nfor objects implemented for requirement M5\nTable 3.2:Should haves\nS1 Content scaling\nThe language should be able to adapt generation based on parameters, to ensure\nscalability of the map and its content, by increasing difficulty and level as deemed\nappropriate by the developer. Thus, each time a new map and its content are going\nto be created, developers can adjust the desired difficulty accordingly.\nS2 Property value generation\nThe language should be capable of randomly generating property values for ob-\njects implemented for requirement M5.  Once these objects are implemented,  the\ncode should have the capability to assign random properties values.  For example,\nfor orcs, these properties values could include stats such as their health or attack\ndamage.   This  would  provide  a  clear  overview  of  the  various  attributes  objects\ncould possess, making object creation during development faster.\n3.3.3    Could Have\nCCould have\nC1Language  could  support  multiple  output  formats,  depending  on  user’s\nneeds\nC2Language could support file separation, to allow for libraries\nC3The language could include a utility function that displays the output of\nthe user’s script\nTable 3.3:Should haves",
      "claims": [
        {
          "text": "The language should be able to alter its generation based on parameters such as level or desired difficulty",
          "flag": false
        },
        {
          "text": "The language should be able to randomly generate values for properties for objects implemented for requirement M5",
          "flag": false
        },
        {
          "text": "The language should adapt generation based on parameters, to ensure scalability of the map and its content, by increasing difficulty and level as deemed appropriate by the developer",
          "flag": false
        },
        {
          "text": "Each time a new map and its content are going to be created, developers can adjust the desired difficulty accordingly",
          "flag": false
        },
        {
          "text": "The language should be capable of randomly generating property values for objects implemented for requirement M5",
          "flag": false
        },
        {
          "text": "Once these objects are implemented, the code should have the capability to assign random properties values",
          "flag": false
        },
        {
          "text": "For orcs, these properties values could include stats such as their health or attack damage",
          "flag": false
        },
        {
          "text": "This would provide a clear overview of the various attributes objects could possess, making object creation during development faster",
          "flag": false
        },
        {
          "text": "The language could support multiple output formats, depending on user's needs",
          "flag": false
        },
        {
          "text": "The language could support file separation, to allow for libraries",
          "flag": false
        },
        {
          "text": "The language could include a utility function that displays the output of the user's script",
          "flag": false
        }
      ]
    },
    {
      "number": 44,
      "originalText": "3.3.   MoSCoW requirements29\nC1 Multiple output formats\nThis is similar to M2, but the requirement is to ensure that the language supports\nmultiple export formats, allowing users to choose the export format.  This would\nfacilitate  better  integration  with  various  game  engines,  and  enable  exporting  in\nformats supported by them, thus simplifying integration into the game later on.\nC2 File seperation\nFile  separation  could  allow  for  code  to  be  separated  into  multiple  files  instead\nof having everything in one.  It would also enable the creation of libraries in the\nprogramming language, as you can import different files into your own code.\nC3 Utility functions\nOne of these functions could allow the user of CARL to view the output of their\nprogram by printing some extra text in the output file mentioned in 3.3.1 which\nwould  display  how  the  map  as  a  string  based  form  as  seen  in  3.1.   This  would\neliminate the need to parse the output in the game to know if the program written\nin this programming language actually meets the user’s needs.\n3.3.4    Won’t Have\nWWon’t have\nW1The language will not be able to interface with functions written in other\nlanguages\nTable 3.4:Won’t haves\nW1 Interfacing with foreign functions\nDeveloping  a  way  for  the  language  to  interface  with  functions  written  in  other\nlanguages, such as C, Python, or JavaScript, might be possible via those languages’\nForeign  Function  Interfaces  (FFI).  While  such  functionality  would  be  useful  for\nusers who would prefer to do the bulk of their coding in a different language, the\nimplementation of this would require researching various languages’ FFIs and tests\nwritten  in  both  CARL  and  other  languages.  This  might  introduce  complications\nthat could end up overshadowing other requirements more directly relevant to the\nproblem statement.",
      "claims": []
    },
    {
      "number": 45,
      "originalText": "30Chapter 3.   Requirements\n3.4    Summary\nIn the prototype and criteria sections, the abstract guidelines of the language were\noutlined. Following these guidelines, the requirements for CARL were established\nthrough the MoSCoW model.  With the guidelines and the more concrete require-\nments, the more specific design choices for the language can be developed, while\nmaintaining these focuses throughout the designing.",
      "claims": [
        {
          "text": "the abstract guidelines of the language were outlined",
          "flag": false
        },
        {
          "text": "the requirements for CARL were established through the MoSCoW model",
          "flag": false
        }
      ]
    },
    {
      "number": 46,
      "originalText": "Chapter 4\nLanguage design\nIn  this  section,  the  specific  aspects  of  CARL’s  language  design,  necessary  for  its\ncorrect implementation, will be presented.  First, the Syntax design where Opera-\ntors, Context-Free Grammar (CFG), Control Structures, and built-in functions, will\nbe discussed and designed. Also in the CFG section, the parser and the lexer used\nin CARL will be outlined.  This will be followed by the semantics design,  where\nthe meaning and evaluation of the language will be outlined.  The evaluation will\nbe described using a transition system and scope.  Additionally,  the type system\nwill follow the transition system, outlining the rules for type usage.\n4.1    Paradigm\nAn early design decision, that would dictate how programs written in the language\nare structured,  is which language paradigm would be used.  In particular,  it was\nconsidered whether to support declarative or imperative design.\nFunctional programming languages are the most common type of declarative lan-\nguages.   A  functional  programming  language  primarily  uses  recursive  functions\nto  control  program  flow.   Depending  on  how  \"pure\"  it  is,  it  might  restrict  vari-\nable assignment after initialisation [28].  These can be useful when implementing\nmathematical algorithms, as they are often described in terms of functions.\nAn  imperative  programming  language,  however,  will  describe  computations  as\na  series  of  steps,  relying  on  the  mutation  of  variables  to  achieve  a  desired  state\n[28].  Imperative languages can be structured procedurally or in an object-oriented\nfashion.\n31",
      "claims": []
    },
    {
      "number": 47,
      "originalText": "32Chapter 4.   Language design\nIn  the  end,  a  procedural  paradigm  was  chosen,  as  most  of  the  map  generation\nalgorithms encountered in the problem analysis stage were described procedurally,\nnot  functionally.   An  added  advantage  would  be  that  if  the  user  has  experience\nwriting  in  C++,  C#,  or  Java  (common  game  development  languages),  they  will\nalready be familiar with imperative paradigms, making it easier for them to learn\nthe language.\n4.2    Syntax\nSyntax  design  is  about  designing  what  the  language  should  look  like,  and  how\nit  should  be  structured  [28].   This  section  will  also  explain  how  tokens  of  CARL\nshould  be  interpreted  informally,  with  the  formal  description  coming  in  section\n4.3.\n4.2.1    Data Types and Structures\nData types are a fundamental aspect of programming languages, and as mentioned\nin criteria 3.2 CARL will also enforce data types. Data types are used to define the\ntype of data that can be stored and manipulated within a program. Common ones\ninclude integers, floating-point numbers, strings, and booleans.\nSome  data  types  can  be  very  important  in  the  development  of  roguelike  games.\nIntegers  for  health  points  or  map  size,  strings  for  entity  name  representation,\nwhere entity describes a kind of NPC, and booleans for state management.  Simi-\nlarly, CARL will include the primitive data types:INT,STRING,BOOLEAN, and\nFLOAT, where float type, could be useful for implementing algorithms that require\nfloating-point arithmetic.\nThe list of primitive data types can be seen in the table below.\nPrimitive typeExplanation\nINTAn integer number which can be either negative or positive\nFLOATA floating-point number which can be either negative or posi-\ntive\nSTRINGA combination of characters within a double quotation\nBOOLEANA true or false value\nTable 4.1:Primitive data types in CARL",
      "claims": []
    },
    {
      "number": 48,
      "originalText": "4.2.   Syntax33\nIn CARL, a user can declare a variable as demonstrated in the listing 4.1.\n1var x : string = \"Orc  monster\"\nListing 4.1:Variable declaration of a string in CARL\nListing  4.1  depicts  a  string  variable  declared  in  CARL.  It  was  decided  to  avoid\nuninitialised variables, as it could lead to potential issues in the code, such as null\nvalues.  By having variables initialised at declaration,  the code becomes easier to\nread.\nIn  addition,  composite  data  types,  such  as  arrays  or  structs,  are  vital  for  organ-\nising  game  elements  like  maps  or  entities  within  the  context  of  CARL.  When  it\ncomes to generating maps, users need efficient means to represent various compo-\nnents, including tiles and monsters. The table below outlines composite data types\navailable in CARL.\nComposite typeExplanation\nSTRUCTA user-defined data structure holding various types\nARRAYAn n-dimensional list holding one kind of data type within\nTable 4.2:Composite data types in CARL\nIn  CARL,  a  struct’s  declaration  has  similarity  to  other  programming  languages,\nbut is a different concept.  Comparing to concepts from object-oriented design,  a\nstruct in C is similar to a class, whereas a struct in CARL acts more like an object.\nIt  allows  for  the  encapsulation  of  multiple  data  types  and  can  be  used  to  define\nspecific user-defined data structures.  Below is an example of a struct definition in\nCARL.\n1var  Orc : Enemy = {\n2var  health : int = 500\n3var  symbol : string = \"O\"\n4}\nListing 4.2:Struct declaration in CARL\nListing 4.2 illustrates a struct declaration in CARL. Structs are declared similarly\nto variables but can contain non-primitive types, allowing for grouping of various\nuser-defined  elements.Orcserves  as  the  identifier  for  the  struct,  whileEnemy",
      "claims": []
    },
    {
      "number": 49,
      "originalText": "34Chapter 4.   Language design\nacts as a non-primitive type, linkingOrcto theEnemystruct by storing it within\ntheEnemytype as a list.  The structOrcis distinct from an instance ofEnemy,\ninstead, it possesses its own unique attributes.\nAccessing a struct involves using dot notation, wherein the type of the struct pre-\ncedes its subtypes.  This allows for easy customisation of game elements.  Listing\n4.3 illustrates struct access within CARL.\n1Enemy.Orc.health = 200\nListing 4.3:Struct access in CARL\nLike structs,  arrays in CARL. are defined similarly to other general-purpose lan-\nguages.  They can hold multiple instances of a single data type and are accessed\nusing  integer  indices.   While  they  can  be  of  n  dimensions,  for  brevity,  examples\nwill only illustrate of 1-dimensional and 2-dimensional arrays.\n1//1-d array of int\n2var  xArray1D : int  [5]\n3//2-d array  string\n4var  xArray2D : string  [10][10]\nListing 4.4:Array declaration in CARL\nListing  4.4  demonstrates  the  definition  of  arrays  in  CARL.  Arrays  can  be  of  any\nprimitive type. Accessing and assigning values within arrays is depicted below. In\nthe example, the arrays are statically sized.  Static sized arrays are beneficial when\ndefining  a  fixed  grid  size  for  a  map,  ensuring  consistent  dimensions  throughout\nthe program’s execution.\n1//1-d array  access\n2var x : int = xArray1D  [2]\n3//2-d array  assignment\n4xArray2D  [2][2] = \"f\"\nListing 4.5:Array access in CARL\nListing  4.5  illustrates  how  both  arrays  gets  accessed  and  assigned  values.   These\ncapabilities allow for efficient organisation and manipulation of data within CARL.",
      "claims": [
        {
          "text": "Language design acts as a non-primitive type",
          "flag": false
        },
        {
          "text": "The struct Orc is distinct from an instance of Enemy",
          "flag": false
        },
        {
          "text": "Structs possess their own unique attributes",
          "flag": false
        },
        {
          "text": "Accessing a struct involves using dot notation",
          "flag": false
        },
        {
          "text": "This allows for easy customisation of game elements",
          "flag": false
        },
        {
          "text": "Arrays in CARL are defined similarly to other general-purpose languages",
          "flag": false
        },
        {
          "text": "They can hold multiple instances of a single data type and are accessed using integer indices",
          "flag": false
        },
        {
          "text": "Arrays can be of n dimensions, but examples will only illustrate 1- and 2-dimensional arrays",
          "flag": false
        },
        {
          "text": "Arrays can be of any primitive type",
          "flag": false
        },
        {
          "text": "Accessing and assigning values within arrays is depicted below",
          "flag": false
        },
        {
          "text": "Static sized arrays are beneficial when defining a fixed grid size for a map",
          "flag": false
        }
      ]
    },
    {
      "number": 50,
      "originalText": "4.2.   Syntax35\n4.2.2    Operators\nOperators are symbols that instruct the computer to carry out a specific arithmetic,\nrelational, or logical operations.  Operators often manifest as symbols such as\n+,\n-,||,  or==,  but  some  languages  might  choose  to  represent  them  differently.\nFor  example  in  Python  you  have  the  choice  to  useandinstead.   CARL  aims  to\nfacilitate the creation of algorithms, and choosing good operators plays a key role\nin doing this.\nArithmetic operators\nArithmetic  operators  are  the  tools  that  allow  us  to  conduct  basic  calculations.\nWhether it is addition, subtraction, division, or multiplication, these operators act\non numbers or variables that refer to number values, to produce a numerical out-\ncome, forming the basics of arithmetic expressions in code. [9]\nArithmetic operatorsExplanation\nADDITIONx + 2\nSUBTRACTIONx - 2\nMULTIPLICATIONx * 2\nDIVISIONx / 2\nMODULUSx % 2\nTable 4.3:Arithmetic Operators\nCARL will use symbols such as\n+for addition,*for multiplication,-for sub-\ntraction,/for division, and%for modulus.  Each of these symbols are standard\nfor their respective arithmetic operations in other languages, such as C.\nRelational operators\nRelational operators in programming enable the comparison of values. They assess\nconditions such as equality, greater than, or less than, producing boolean values,\nTrueorFalse.  These operators are pivotal in control structures, allowing programs\nto make decisions based on comparative results.",
      "claims": []
    },
    {
      "number": 51,
      "originalText": "36Chapter 4.   Language design\nRelation operatorsExplanation\nEQUALx == 3\nNOT EQUALx != 3\nGREATER THANx > y\nLESS THANx < y\nLESS THAN OR EQUALx <= y\nGREATER THAN OR EQUALx >= y\nTable 4.4:Relation operators\nFor relational operators, CARL will use the same ones as most C-based program-\nming languages, which can be viewed in table 4.4.\nLogical operators\nLogical operators are the backbone of decision-making in control structures.  They\ncombine multiple conditions to yield a single boolean outcome. By utilising opera-\ntors like\nAND,OR, andNOT, programs can evaluate complex expressions, dictating\nthe flow of execution based on multiple criteria[38].  This also makes improves the\noverall syntax of CARL 3.2, as it is clear what these operators do.\nLogical OperatorsExplanation\nANDif x == 3 AND y == 4\nORif x == 3 OR y == 4\nNOTif !True\nTable 4.5:Logical Operators\nFor logical operators, CARL will use capitalised words such asAND,OR, andNOT,\nrather than the\n&&,||, and!of C-like languages.\nCustom operator\nThe custom operator\nx..ycan be used to return a random number, either integer\nor float, between x and y. This can be beneficial when wanting to randomise certain\naspects of the map within a certain range.",
      "claims": [
        {
          "text": "CARL will use the same relation operators as most C-based programming languages.",
          "flag": false
        },
        {
          "text": "The relational operators can be viewed in table 4.4.",
          "flag": false
        },
        {
          "text": "Logical operators are the backbone of decision-making in control structures.",
          "flag": false
        },
        {
          "text": "Logical operators combine multiple conditions to yield a single boolean outcome.",
          "flag": false
        },
        {
          "text": "Programs can evaluate complex expressions, dictating the flow of execution based on multiple criteria.",
          "flag": false
        },
        {
          "text": "The overall syntax of CARL 3.2 is improved by logical operators.",
          "flag": false
        },
        {
          "text": "It is clear what these operators do in CARL 3.2.",
          "flag": false
        },
        {
          "text": "CARL will use capitalised words such as AND, OR, and NOT for logical operators.",
          "flag": false
        },
        {
          "text": "The custom operator x..y can be used to return a random number, either integer or float, between x and y.",
          "flag": false
        }
      ]
    },
    {
      "number": 52,
      "originalText": "4.2.   Syntax37\n4.2.3    Control Structures\nAs CARL must support the implementation of algorithms, employing control struc-\ntures  are  pivotal  in  supporting  this.   Control  structures  are  defined  as  structures\nused  in  programming  languages  to  control  the  flow  or  execution  of  a  program\n[18].   There  are  three  main  categories  of  control  structures:  Sequence  structures,\nselection structures, and iteration structures.\nWhen addressing control structures, it is important to understand how these con-\ntrol structures guide the program. The instruction that the instruction pointer will\npoint to next can be altered by control flow statements.  An example of an uncon-\nditional control statement in a low-level homemade language could be the \"goto\"\nstatement.\n1statement1;\n2goto  jumplabel:\n3statement2; // This  line is  skipped\n4jumplabel:\n5statement3;\nListing 4.6:Goto listing\nIn  the  listing  4.6  there  is  an  example  of  how  an  unconditional  control  structure\nworks. Here the IP will first point to line 1, execute it, then point to line 2 and then\nexecute that. The IP will then point to the\nstatement3because the goto will go to\nthejumplabelstatement which points to line 5, which is the statement after the\njump label statement. From this point, the normal flow can continue until it meets\nanother control flow statement.  CARL will not have goto statements, as they are\nnot used in the algorithms that have been researched in the problem analysis.\nSequence structures\nSequential flow also known as \"normal flow\" or \"straight-line code\" is the simplest\ntype of program flow.The program execution flows from one statement to the next\nunconditionally.   In  C  and  C-derived  languages,  this  is  written  as  one  statement\nafter another:\n1statement1;\n2statement2;\n3statement3;\nIn this example,statement1would be executed,  followed bystatement2,  and\nfinallystatement3. CARL will follow this logic of execution.",
      "claims": []
    },
    {
      "number": 53,
      "originalText": "38Chapter 4.   Language design\nSelection structures\nSelection structures allow for conditional flow of the programs.  This means that\ndepending on a condition, the program may choose between two or more alterna-\ntive courses of action.\nExamples of such structures include\nifstatements andswitchstatements imple-\nmented by some languages.  In addition, the syntax design of these will be similar\nin CARL, with the use of for example of ’if’ keyword.\n1if  condition{\n2statement1;\n3} else {\n4statement2;\n5}\nListing 4.7:Example of CARL selection structur using if-statement\nThe condition will be evaluated either to \"true\" or \"false\".  If the condition evalu-\nates  to  \"true\",  the  program  will  executestatement1.   Otherwise,  it  will  execute\nstatement2.  CARL will have this selection structure as it expands the options of\nhow to make algorithms.\nIteration structures\nIteration structures allow a group of operations to be repeated. Languages usually\nallow users to specify that the loop must be repeated a certain number of iterations,\nor only while a condition applies.  In C and C-derived languages,  these can take\nthe form of \"for\" loops, \"while\" loops, or \"do-while\" loops.\n1while  condition {\n2loop -body;\n3}\nListing 4.8:Example of CARL ́s repetition structur using while-loop\nThis will repeatloop-bodyas long as theconditionholds true. CARL will have\nthe while loop, as this is a pivotal part of implementing the algorithms needed in\nroguelike map generation. Some of these constructs will be implemented in CARL,\nbut the intention of CARL, as mentioned in the section on criteria??, is to maintain\nsimplicity by using only a few constructs.  These include if-statements and while-\nloops,  which can perform the same functions as switch-statements and for-loops\nbut may be easier for uses of CARL to understand.",
      "claims": []
    },
    {
      "number": 54,
      "originalText": "4.2.   Syntax39\n4.2.4    Built-in functions\nAs mentioned in the criteria section 3.2, CARL is expected to support abstraction,\nan important aspect of the language. This support for abstraction is intended to be\nimplemented through built-in functions.  These built-in functions can assist devel-\nopers in creating the map, thereby ensuring the fulfillment of the MVP described\nin section 3.3.\nFunctions\ngenerateMap(height, width)\ngenerateRooms(roomCount,minRoomSize,max-\nRoomSize)\ngenerateCorridors()\ngenerateSpawns(difficulty)\nprintMap()\nwriteToFile()\nsetSeed(seed)\nwriteToFile()\nprint(\"This will get printed to the console\")\ngeneratePrint()\nTable 4.6:Table of built-in functions in CARL.\nFunction descriptions\nIn the table 4.6, some of the functions that are built-in to CARL can be seen.\ngenerateMap(height, width)\nThe\ngenerateMapfunction initialises the map’s grid with a height and a width,\nsetting  all  tiles  to  wall  tiles,  representing  walls.   This  will  be  the  map  that  will\ncontain all the content which can be manipulated with algorithms.\ngenerateRooms(roomCount, minRoomSize, maxRoomSize)\nThe function\ngenerateRoomscreates rooms on the provided grid. It utilises the pa-\nrameters\nminRoomSizeandmaxRoomSizeto generate rooms with semi-randomised\nsizes,  selecting  a  size  between  the  specified  minimum  and  maximum  values.   It",
      "claims": [
        {
          "text": "CARL is expected to support abstraction",
          "flag": false
        },
        {
          "text": "abstraction is implemented through built-in functions",
          "flag": false
        },
        {
          "text": "built-in functions can assist developers in creating the map",
          "flag": false
        },
        {
          "text": "the MVP described in section 3.3 will be fulfilled",
          "flag": false
        },
        {
          "text": "generateMap function initialises the map's grid with a height and a width",
          "flag": false
        },
        {
          "text": "all tiles are set to wall tiles, representing walls",
          "flag": false
        },
        {
          "text": "the generateRooms function creates rooms on the provided grid",
          "flag": false
        },
        {
          "text": "rooms are generated with semi-randomised sizes",
          "flag": false
        }
      ]
    },
    {
      "number": 55,
      "originalText": "40Chapter 4.   Language design\nthen populates the grid with floor tiles for each generated room, if the grid is not\nalready populated with floor tiles.\ngenerateCorridors()\nThe\ngenerateCorridorsfunction ensures the placement of corridors between the\ncreated rooms.  It iterates through all the rooms, creating corridors between adja-\ncent rooms. It determines the centre points of adjacent rooms, then generates both\nhorizontal  and  vertical  corridors  between  them.   These  corridors  are  then  popu-\nlated with floor tiles to connect the rooms.\ngenerateSpawns(difficulty)\nThis function generates the spawn points of monsters within the map.  It utilises\nthe difficulty parameter to determine the number of spawnable monsters and ran-\ndomly places them in all rooms except the last one.  It achieves this by randomly\nselecting an x and y coordinate within a random room and placing a monster on\nthe  tile  if  it  is  not  already  occupied.   It  also  generates  the  player’s  spawn  point\nwithin the created map.  It selects random x and y coordinates from the last room\nand places the player within this room.\nprintMap()\nThe\nprintMapfunction displays the entire map in the same string format as the\nprototype described in section 3.1.  It utilises values generated within the private\nfunctiongeneratePrintand outputs them to the console.\nwriteToFile()\nThewriteToFilefunction takes the format generated bygeneratePrint, creates\na designated file named map.json, and saves the map data to this JSON file.\nsetSeed(seed)\nThis  function  is  used  to  set  a  seed  for  the  map  generation  process,  enabling  the\ncreation of deterministic maps.  If a seed argument is provided, it sets the map’s\nseed to this value, otherwise, it generates a random seed.\nprint()The\nprintfunction works similarly to other programming languages, en-\nabling  print  statements,  such  as  variables,  strings,  value  etc.   This  can  make  it\neasier to for the developer to test various variables for its value, gaining additional\ninformation.  This is not necessary for the MVP3.3.1,  but is a nice feature for the\ndeveloper.   To  print  multiple  values  at  once,  you  use  comma  separation,  which",
      "claims": [
        {
          "text": "the grid is not already populated with floor tiles",
          "flag": false
        },
        {
          "text": "it determines the centre points of adjacent rooms",
          "flag": false
        },
        {
          "text": "corridors between them are then populated with floor tiles to connect the rooms",
          "flag": false
        },
        {
          "text": "the difficulty parameter determines the number of spawnable monsters",
          "flag": false
        },
        {
          "text": "randomly places them in all rooms except the last one",
          "flag": false
        },
        {
          "text": "randomly selects an x and y coordinate within a random room and places a monster on the tile if it is not already occupied",
          "flag": false
        },
        {
          "text": "it also generates the player's spawn point within the created map",
          "flag": false
        },
        {
          "text": "selects random x and y coordinates from the last room and places the player within this room",
          "flag": false
        },
        {
          "text": "the printMap function displays the entire map in the same string format as the prototype described in section 3.1",
          "flag": false
        },
        {
          "text": "it utilises values generated within the private function generatePrint and outputs them to the console",
          "flag": false
        },
        {
          "text": "the writeToFile function takes the format generated by generatePrint, creates a designated file named map.json, and saves the map data to this JSON file",
          "flag": false
        },
        {
          "text": "if a seed argument is provided, it sets the map's seed to this value, otherwise, it generates a random seed",
          "flag": false
        },
        {
          "text": "it enables the creation of deterministic maps",
          "flag": false
        }
      ]
    },
    {
      "number": 56,
      "originalText": "4.2.   Syntax41\nadds a space between the values.  The print function adds a newline at the end by\ndefault.\n4.2.5    Context-free grammar\nAfter detailing the language’s structure, operators, and functions, it is useful to set\nup its syntax rules using a Context-Free Grammar (CFG).\nThe CFG is used for compiling syntactical rules into a format suitable for building\nparsers. It consists of production rules that specify how terminal and non-terminal\nsymbols can be combined to generate valid language strings.\nThe  CFG  was  initially  written  into  a  text  file  and  then  configured  in  an  ANTLR\n4  (Another  Tool  for  Language  Recognition)  file.   The  utilisation  of  ANTLR  was\nuseful for developing a more comprehensive CFG, and will continue to be utilised\nwhen creating the parser and lexer.  ANTLR 4 uses Extended Backus–Naur Form\n(EBNF), accommodating regular expression symbols such as ’*’, denoting zero-to-\nmany  occurrences,  ’+’,  indicating  one-to-many,  ’|’  for  or,  and  more,  which  can\nsimplify  the  creation  of  the  syntax  in  CARL  [20].   An  ANTLR  4  example  of  the\nCFG for CARL is depicted below.\n1grammar  CARL;\n2\n3program : statement* EOF;\n4\n5statement\n6: assignment\n7| functionCall\n8| functionDefinition\n9| ifStatement\n10| whileLoop\n11| returnStatement\n12| structureDefinition\n13| importStatement\n14| variableDeclaration\n15| arrayDeclaration\n16| coordinateDeclaration\n17| methodCall\n18| propertyAssignment\n19;\nListing 4.9:CFG for CARL\nListing 4.9 illustrates the syntax for statements and program in the CARL language.",
      "claims": [
        {
          "text": "Syntax adds a space between values.",
          "flag": false
        },
        {
          "text": "The print function adds a newline at the end by default.",
          "flag": false
        },
        {
          "text": "A Context-Free Grammar (CFG) is used for compiling syntactical rules into a format suitable for building parsers.",
          "flag": false
        },
        {
          "text": "The CFG consists of production rules that specify how terminal and non-terminal symbols can be combined to generate valid language strings.",
          "flag": false
        },
        {
          "text": "ANTLR 4 uses Extended Backus–Naur Form (EBNF).",
          "flag": false
        },
        {
          "text": "Regular expression symbols such as '*' denote zero-to-many occurrences, '+' indicates one-to-many, '|' for or, and more, which can simplify the creation of syntax in CARL.",
          "flag": false
        }
      ]
    },
    {
      "number": 57,
      "originalText": "42Chapter 4.   Language design\nNotably, a program can encompass zero-to-many ’*’ statements, followed by ’EOF’,\nsignifying no more statements to follow. Moreover, statements are separated by ’|’,\nindicating the variety of possible statements.\n1variableDeclaration : ’var ’ IDENTIFIER  ’:’ type  ’=’ (expression) ;\nListing 4.10:Variable declaration in CARL\nListing 4.10 shows the process of declaring a variable in CARL. In this language, a\nvariable declaration commences with the keyword ’var’, followed by an identifier\n(a token in the CFG lexer, which will be expanded deeper into later), a type (see\nAppendix), and finally, an expression assigned using the ’=’ operator token.\nIn CARL, expressions adhere to a similar structure as statements, offering a variety\nof possible expressions. This is depicted in listing 4.11:\n1expression\n2: primary\n3| ’!’ expression\n4| expression  op=(’*’ | ’/’ |  ’%’) expression\n5| expression  op=(’+’ | ’-’) expression\n6| expression  op=(’<’ | ’<=’ | ’>’ | ’>=’ |  ’==’ |  ’!=’)  expression\n7| expression  op=(’AND ’ | ’OR ’)  expression\n8| expression  ’..’ expression\n9;\nListing 4.11:Expressions in CARL\nAdditionally, listing 4.11 showcases how ANTLR 4 manages operator precedence,\nprioritizing operations based on their order of definition.  The highest precedence\nis accorded to the unary expression ’!’, with additional operations following in de-\nscending order of priority [20]. It also supports left-recursion, allowing expressions\nto be within each other. For instance, ’1 + (2 + 3) + 3’ is valid, where the expression\nfollows the pattern ’expression + (expression + expression) + expression’ [27]. The\nfull grammar can be seen in Appendix B.\n4.2.6    Lexer\nA lexer is the part of a compiler or interpreter,  responsible for transforming and\nvalidating source code into tokens that the parser can comprehend and use [20].\nThe  lexer  disassembles  the  source  code  into  a  sequence  of  tokens.   The  tokens\nencompass  keywords,  symbols,  and  identifiers,  which  the  parser  later  utilises  to",
      "claims": []
    },
    {
      "number": 58,
      "originalText": "4.2.   Syntax43\ninfer  the  code’s  structure  [20].   In  the  context  of  CARL,  certain  lexer  rules  are\ndefined within the CFG. These rules dictate how the lexer identifies and tokenises\ndifferent elements of the source code.\n1INT : [0 -9]+ ;\n2FLOAT : [0 -9]*  ’.’ [0-9]+ ;\n3STRING : ’\"’ ~[\"]*  ’\"’ ;\n4BOOL : (’true ’ | ’false ’) ;\n5IDENTIFIER : [a-zA-Z_][a-zA -Z0 -9_]* ;\n6WS : [ \\t\\r\\n]+ -> skip ;\n7LINE_COMMENT :  ’//’ ~[\\r\\n]* -> skip ;\nListing 4.12:Lexer rules in CFG\nListing 4.12 illustrates the lexer rules defined in CARL using ANTLR formatting.\nIt  can  be  seen  that  the  lexer  rules  are  written  using  regular  expression  notation,\nwith  each  rule  consisting  of  an  all-caps  identifier  followed  by  its  definition.   In\naddition, the notation\n-> skipindicates that certain tokens, such as whitespace\ncharacters and comments, will not be passed to the parser and thus excluded from\nthe parse tree [20].  This formatting makes it easier to understand when reading\nthe construction of the parse tree.\n4.2.7    Parser\nA parser can then be used to generate a parse tree based on the given CFG for the\nlanguage CARL, and the input string from the lexer. The parser operates by taking\nthe tokens from the lexer checking if the tokens follow the rules of the CFG, and\nthen generating the parse tree for the given source code [27].\nOne  of  the  main  parsing  types  is  top-down  parsing,  which  is  used  in  the  pars-\ning generator tool ANTLR. Top-down parsing begins from the root and progresses\ndownward, adhering to the leftmost derivation (LL) by selecting the leftmost ele-\nment and applying CFG rules to expand it [27].\nANTLR  4 makes  use  of LL,  but  uses LL(*),  meaning  that the  parser  will look  as\nmany  tokens  ahead  as  needed  [20],  making  it  more  efficient  and  provide  more\ninformative errors.  ANTLR will be used in this project to generate the parser and\nlexer. The choice of ANTLR 4 will be explained further in section 5.3.",
      "claims": []
    },
    {
      "number": 59,
      "originalText": "44Chapter 4.   Language design\n1if true {\n2var x : int = 3\n3return x\n4}\nListing 4.13:CST code example\nIn Listing 4.13, one can see an example of an if statement in CARL. When this code\nis given to ANTLR with CARL’s CFG, ANTLR can generate a Concrete Syntax Tree\n(CST).\nFigure 4.1:CST in CARL\nAn example of a parse tree can be seen in Figure 4.1.  Here, the parse tree depicts\nthe tree’s root that represents the entire program in CARL. The program branches\nout  to  an\nifStatementcondition  that  checks  if  an  identifier  is  true.  Within  the\nconditional’s  block,  that  is  defined  by  curly  braces,  there  is  a  declaration  of  an\ninteger variable x initialized to 3.  The block concludes with a\nreturnStatement,\nwhich returns the value of x.  The program will then terminate with an end-of-file\n(EOF) token.",
      "claims": [
        {
          "text": "ANTLR can generate a Concrete Syntax Tree (CST)",
          "flag": false
        },
        {
          "text": "An example of a parse tree can be seen in Figure 4.1",
          "flag": false
        },
        {
          "text": "The program branches out to an ifStatementcondition that checks if an identifier is true",
          "flag": false
        },
        {
          "text": "Within the conditional's block, there is a declaration of an integer variable x initialized to 3",
          "flag": false
        },
        {
          "text": "The block concludes with a returnStatement, which returns the value of x",
          "flag": false
        }
      ]
    },
    {
      "number": 60,
      "originalText": "4.3.   Semantics45\n4.3    Semantics\nFor  the  design  of  the  language,  another  important  aspect  is  the  semantic  phase.\nSemantics  are  models  and  procedures  that  describe  formally  and  informally  the\nlogic and evaluation of the execution within the programming language [19]. This\nsection will rely on the book “Transition and trees”, by Hans Hüttel that describes\nthe  steps  to  analyse  the  semantics  of  a  programming  language.   Additionally,  it\nmust be stated that the formal description of the transition/type rules corresponds\ndirectly to the lecture slides of Giorgio Bacci, in his course \"Syntax and Semantics\"\nfor Aalborg University. These can be found online[3]. The reason for this is that the\nsemantics of the language BIMS, taught by Bacci, are almost identical to those of\nCARL, with the exceptions being the ’..’  operator and the formation rules syntax.\nWith the sources outlined, the semantic part can begin.  An illustrative example of\nsemantic error could be the sentence “I am a car”. The structure of the sentence is\ngrammatically/syntactically correct, but it lacks semantic coherence.\n4.3.1    Abstract syntax\nWhen it comes to semantic analysis, the whole syntax is not necessary, as one can\nanalyse  the  abstract  syntactical  categories  instead.   The  first  step  in  making  this\nanalysis is defining the syntactical categories, which then can be used to define the\nrest of logic in CARL. These abstract syntax categories were made with the CFG\nproduction rules in mind.",
      "claims": []
    },
    {
      "number": 61,
      "originalText": "46Chapter 4.   Language design\nAbstract syntax\nn∈Num−Numerals\nx∈Var−Variables\nb∈Bexp−Boolean expression\na∈Aexp−Arithmetic expression\ne∈Exp−Expressions\nS∈Stm−Statements\nP∈ParList−Parameter List\nT∈Type−Types\nf∈Fn−Function\nsn∈Sn−Struct\nd∈Dec−Declaration\nfl∈Flo−Float Literal\nin∈Int−Int Literal\nTable 4.7:Syntactic categories [3]\n4.3.2    Formation rules\nThe formation rules using the syntactic categories of CARL. in figure 4.2.",
      "claims": []
    },
    {
      "number": 62,
      "originalText": "4.3.   Semantics47\nS::=S1;S2|ifb S1 elseS2|whilebdoS|d\nf\n|d\nx\n|d\ns\n|x=e|f(x\n1\n, ...,x\nn\n)\ne::=b|a|f(x\n1\n, ...,x\nn\n)\nb::=x|b1==b2|b1!=b2|a1<a2|a1>a2|a1<=a2|a1>=a2|!b|(b)|true|f alse\n|b1AN D b2|b1OR b2\na::=x|in|f l|a1+a2|a1−a2|a1∗a2|a1/a2|a1%a2|a1..a2|(a)\nT::=in|fl|bool\nd\nx\n::=var x:T= (e|struct)\nd\nf\n::=f n  f(P)->T{S}\nd\ns\n::=struct sn{xd\n1\n, ...,xd\nn\n}\nd::=d\nx\n|d\nf\n|d\ns\nP::=ε|x:T\nFigure 4.2:Formation Rules\nThe formation rules depicted in Figure 4.2 outline the constructs applicable within\nCARL. An example is struct declaration (sd) in CARL, utilised for defining objects\nwithin the map. A struct comprises a keyword followed by the struct name, along\nwith variable declarations enclosed within brackets.  The ’..’  arithmetic expression\nrule has been integrated into CARL, which allows for a generated random number\nwithin a specified range to be returned.\nMost  rules  adhere  to  generic  conventions  such  as  a  C-based  syntax,  changes\nprimarily pertain to formatting,  and so the focus will be on the more interesting\nformation rules.\n4.3.3    Denoting the syntax values\nThe  formation  rule  seen  above  pertains  to  syntax,  and  some  of  the  meaning  of\nthe structural statements and operational semantics has been informally assigned\nin the section 4.2.  The relationship between syntax and semantics could perhaps\nbe  understood  through  an  example:  \"Quppeg\"  is  a  made-up  word  consisting  of\nsymbols, and is thus syntax.  To give this made-up word meaning, one denotes its\nsemantics.  \"Quppeg\" now refers to a greenhouse that embodies comfort.  This is\nalso the process involved in assigning meaning to the syntax in CARL. Here, the\ndenotation of the digits will be highlighted to establish a precise understanding of\ntheir meaning.",
      "claims": [
        {
          "text": "CARL formation rules outline the constructs applicable within CARL.",
          "flag": false
        },
        {
          "text": "Struct declaration (sd) in CARL is used for defining objects within the map.",
          "flag": false
        },
        {
          "text": "A struct comprises a keyword followed by the struct name, along with variable declarations enclosed within brackets.",
          "flag": false
        },
        {
          "text": "'..' arithmetic expression rule has been integrated into CARL.",
          "flag": false
        },
        {
          "text": "The focus will be on the more interesting formation rules in CARL.",
          "flag": false
        },
        {
          "text": "Formation rules pertain to syntax.",
          "flag": false
        },
        {
          "text": "The relationship between syntax and semantics could perhaps be understood through an example.",
          "flag": false
        },
        {
          "text": "The made-up word 'Quppeg' is a symbol consisting of symbols, and is thus syntax.",
          "flag": false
        },
        {
          "text": "To give this made-up word meaning, one denotes its semantics.",
          "flag": false
        },
        {
          "text": "'Quppeg' now refers to a greenhouse that embodies comfort.",
          "flag": false
        },
        {
          "text": "This is also the process involved in assigning meaning to the syntax in CARL.",
          "flag": false
        },
        {
          "text": "The denotation of the digits will be highlighted to establish a precise understanding of their meaning.",
          "flag": false
        }
      ]
    },
    {
      "number": 63,
      "originalText": "48Chapter 4.   Language design\nAxiomatic semanticsBefore delving into the operational semantics, it is necessary\nto first examine some of the axioms in CARL. An axiom describes the foundational\nassumptions  necessary  for  the  basic  elements  of  the  system  [19].   The  semantic\nmeaning  of  the  basic  elements  can  then  later  be  used  in  expressions  and  state-\nments. This section will explain the axiom for floats and integers, as they are used\nin transition rules.\nGetType : Num -> in U fl\nFigure 4.3:Axiom for integer and float\nFigure 4.3 is the axiom for floats and integers. It assumes that there exists a function\nthat can convert a number to either an integer (int) or a float (fl).\n4.4    Environment store model\nAs the language, CARL will have variables and functions, the storage and access of\nthese variables and functions should therefore also be modelled. In this subsection,\nthe scope and storage will be outlined.\n4.4.1    Scope rules in CARL\nWhen designing a programming language, decisions regarding the types of scope\nis crucial.  Scope determines where within the program a variable can be accessed\nand establishes the context in which a name is valid. There are two forms of scope:\nstatic and dynamic. Static scoping uses the value as it was declared, while dynamic\nscoping uses the value as it was called [19]. The listing below illustrates an example\nof scope in CARL.",
      "claims": []
    },
    {
      "number": 64,
      "originalText": "4.4.   Environment store model49\n1var x: int = 0\n2\n3fn p() -> void {\n4x = x + 2\n5}\n6\n7fn q() -> void {\n8p()\n9}\n10\n11fn main() -> int {\n12var x : int = 8\n13fn p() -> void {\n14x = x + 5\n15}\n16q()\n17return x\n18}\n19\nListing 1:Example of scope in CARL using CFG\nIf  static  scoping  for  variables  is  used  in  listing  1,  then  the  variable  would  look\nwhere it was declared.  The initial declaration ofxwould be equal to 0 on line 1,\nthis would then be shadowed by the declaration of\nxinside the function main on\nline 12, which would then be 8.qwould then be called on line 16, but since the\nlanguage assumes static scope rule for variablesxwould remain the same for the\nlocal value that overshadows the global\nx, and the final value ofxwould return\nthe later\nxwhich is 8.\nIn contrast, for dynamic scope rules of variables, the scope would look where the\nvariable whenmainis called.  So again the value ofxwill be equal to 8 on line\n12,  thenmainwill call the functionqon line 16,  which then callspon line 8,\nthe value of\nxis then updated according to whatpholds, such thatxwill be\nupdated,  and  the  final  value  ofxwill  return  10.   CARL  will  use  this  form  of\nscoping for variables.\nIf  fully  dynamic  scope  rules  are  assumed  for  both  functions  and  variables,  the\nscope looks from end to start, and thereby takes the most recent declaration. Here,\nxis  initially  8  on  line  12.   Whenqis  called  on  line  16,  it  looks  forpwithin\nmain, finding the declaration on line 13, which shadows the earlierp.  Thus,p\ninsidemainupdatesx, resulting in the final value ofxbeing 13.\nIn contrast, assuming static scoping for functions with dynamic variable scope, the",
      "claims": []
    },
    {
      "number": 65,
      "originalText": "50Chapter 4.   Language design\nscope would resolve the function to where it was first declared.  Therefore, calling\nqon line 16 would invokepas declared on line 3.  Since the variable scope is\ndynamic, thexinmainwould be updated byp, resulting inxbeing 10.  The\nmixed scope rules are the ones that will be used in CARL.\nVariable environment and the store\nIn  CARL,  three  distinct  environment  categories  emerge  as  essential  for  storage:\nvariables,  functions,  and  structs.   Similarly,  CARL  will  have  dedicated  tables  for\neach of these distinct data categories. The variable environment corresponds to the\n’environment’ within the Environment Store Model, which contains the addresses\nwhere variables are stored and their locations[19].  The ’store’, on the other hand,\nserves as the associative mapping between locations and their respective values[19].\nOne could think of the Environment Store Model as a hashmap.\nVar\nLoc\nV\nvar1\nvar2\nl\n1\nl\n2\n20\n10\nFigure 4.4:Environment Store Model: Variables linked to addresses that are linked to values[3]\nIn  Figure  4.4,  the  structure  of  the  Environment  Store  Model  for  the  value  table\nis  depicted,  showcasing  the  association  of  variables  with  their  respective  values\nwithin a program’s state.  The figure illustrates the stages, Var (Variable), Loc (Lo-\ncation),  and V (Value).  In the Var column,  the variable  identifiers var1 and var2\nare mapped to locations in the Loc column, denoted as l1 and l2.  The locations l1\nand l2 are linked to their respective values in the Val column, showing that var1 is\nassociated with its respective value.  This also illustrates how CARL supports the\nstoring of values.\n4.4.2    Variable model\nThe following section describes how variables will be handled in the environment\nstore model for CARL. An important note: when looking up variables and attempt-\ning  to  retrieve  values  in  the  store  model  that  do  not  exist,  the  ’store’  will  return\nnothing. This behaviour can be described as a partial function.[3]",
      "claims": []
    },
    {
      "number": 66,
      "originalText": "4.4.   Environment store model51\nStore⊢Loc⇀Value\nFigure 4.5:From slides [3]\nFigure 4.5 formally describes the behaviour of looking up a variable in the store\nmodel, where⊢indicates that within the given store, a variable only may return a\nvalue, highlighting that a lookup in the store may not always yield a result.[3]\nStore⊢Loc7→value\nFigure 4.6:From slides [3]\nFigure  4.6  uses  the  maplet  arrow  to  describe  that  each  location  is  mapped  to  a\nvalue.  These figures describe the store model independently of the environment.\nHowever,  the  environment  will  also  be  taken  into  account  when  modelling  the\nEnvironment Store Model of CARL as can be seen in the following figure.[3]\nEnv,store⊢x⇀v\nFigure 4.7:From slides [3]\nIn Figure 4.7, the full behaviour of the lookup is shown.  The figure shows that in\nan environmentenvthat has the variablex, there may be a valuevassociated with\nit.[3]\nEnv,store⊢x7→v\nFigure 4.8:From slides [3]\nFigure  4.8  illustrates  the  behaviour  of  storing  a  value  in  the  environment  store\nmodel corresponding to a  variable[3].  The difference from Figure  4.7 is denoted\nwith  the  maplet  arrow,  highlighting  that  this  variable  in  this  environment  will\nalways have a value stored.\nThe following section describes how the variables will be handled in the environ-\nment store model for the CARL.\n4.4.3    Transition system\nTransition  systems  offer  a  theoretical  model  to  describe  the  behaviour  of  CARL\n[19]. They ensure that the semantics of a language are well-defined by focusing on\nthe transitions between execution states.  In this report, some transition rules will\nbe outlined using the big step notation.  The big step notation is used to illustrate\nhow statements are evaluated in one step[19]. When it comes to the transition rules\nof semantics,  one can separate them into two categories.  One being Operational\ntransition rules, wherein the rules of defining the behavior of operations. The next",
      "claims": []
    },
    {
      "number": 67,
      "originalText": "52Chapter 4.   Language design\nbeing structural operational semantics, which describes the behavior of structures\nwithin the statements of the language. An example of big step semantic operation\ntransition rules in CARL is illustrated below [19].\n[Binary operators]\nenv\nv\n,store\nv\n⊢a\n1\n→v\n1\nenv\nv\n,store\nv\n⊢a\n2\n→v\n2\na\n1\n⋆a\n2\n→v\nwherev=v\n1\n⋆v\n2\n.\nFigure 4.9:star = \"+\" \"-\" \"*\" \"%\" From slides[3]\nThe  first  line  in  figure  4.9,  the  premises/claims  of  the  rule  is  stated.   Here,  the\narithmetic  expressionsa\n1\nanda\n2\n,  are  evaluated  as  valuesv\n1\nandv\n2\naccording  to\nthe  transitional  relation,  by  using  the  axioms  and  transition  rules  until  a→v\nis  reached.   Below  them,  we  have  the  conclusion  thata\n1\n⋆a\n2\nwill  evaluate  to  a\nvalue given the premise above.  The star in the figure is representing the different\noperators  mentioned  in  the  caption.   The  right  side,v=v\n1\n⋆v\n2\n,  represents  the\ncondition/rules for which this transition will be true.  Additionally, if no value is\nfound  from  a,  then  the  condition/rule  will  not  be  valid.  This  in  essence  depicts\nhow  the  programming  language  should  behave  when  executing  the  arithmetic\nexpressions, both evaluating to values.\nThe  transition  rules  that  are  illustrated  will  collectively  become  a  model  of  how\nCARL should behave when encountering these expressions.  CARL ́s operational\nsemantic  transition  rules  are  very  similar  to  C.  Most  operational  semantic  tran-\nsitions  are  generic  for  most  languages,  including  CARL,  and  mostly  interesting\noperations unique to CARL will therefore be highlighted individually.\nRandom operator\nenv\nv\n, store\nv\n⊢a\n1\n→v\n1\nenv\nv\n, store\nv\n⊢a\n2\n→v\n2\na\n1\n..a\n2\n→v\nwherev∼U\n[v\n1\n,v\n2\n)\n,v\n1\n<v\n2\nand GetType(v\n1\n) =Float\nand GetType(v\n2\n) =Float\nFigure 4.10:Transition system for the random operator on floats values",
      "claims": []
    },
    {
      "number": 68,
      "originalText": "4.4.   Environment store model53\nenv\nv\n, store\nv\n⊢a\n1\n→v\n1\nenv\nv\n, store\nv\n⊢a\n2\n→v\n2\na\n1\n..a\n2\n→v\nwherev∼U\n{v\n1\n,v\n2\n−1}\n,v\n1\n<v\n2\nand GetType(v\n1\n) =Int\nand GetType(v\n2\n) =Int\nFigure 4.11:Transition system for the random operator on integer values\nSimilar to binary operators,  the random operator requires that the arithmetic ex-\npressionsa\n1\nanda\n2\n, evaluate to values for the operation to be valid.  Ifa\n1\nanda\n2\nevaluate to values, then the operation will evaluate to a random value between the\ntwo values, using a uniform distribution.\nFigure  4.10  and  Figure  4.11  describes  this  mathematically.   The  notationU\n[v\n1\n,v\n2\n)\nrepresents a continuous uniform distribution betweenv\n1\nandv\n2\n, not includingv\n2\n.\nFigure 4.11 is similar, but uses the notationU\n{v\n1\n,v\n2\n−1}\n, to denote a discrete uniform\ndistribution betweenv\n1\nandv\n2\n, includingv\n1\nbut notv\n2\n.  TheGetTypefunction that\nis  used,  depends  on  whether  the  type  system  described  in  4.4.4  determines  the\noperation’s output to be a ’float’ or an ’int’ (integer).\nStructural Operation Semantics\nIn  the  section  “Control  Structures”  4.2.3,  the  control  flow  structures  were  infor-\nmally explained and illustrated.  In this subsection, some of CARL’s control struc-\ntures will be formally explained.\nenv\nv\n,env\nf\n,env\ns\n⊢⟨S,store⟩→store\n′\nenv\nv\n,env\nf\n,env\ns\n⊢⟨{S},store⟩→store\n′\nFigure 4.12:From slides [3]\nIn Figure 4.12, the behaviour of a block statement can be seen.  The premise states\nthat  there  exists  a  statementS,  which  gets  executed  within  the  environment  for\nvariables,  functions,  and  structs,  potentially  creating  a  newstore\n′\nwith  updated\nvariable bindings. If the premise is correct, the conclusion states that the statement\nSwill be executed, resulting in a change in the store from its initial state to a new\nstatestore\n′\n.",
      "claims": []
    },
    {
      "number": 69,
      "originalText": "54Chapter 4.   Language design\nenv\nv\n,store\nv\n⊢b→venv\nv\n⊢⟨IfbThenS,store⟩→store\n′\nenv\nv\n⊢⟨IfbThenS,store⟩→store\n′\nwhereb→\nEx p\ntt\nFigure 4.13:From slides [3]\nIn  Figure  4.13,  one  can  see  the  behaviour  of  an  if-statement.   The  premises  state\nthat within anEnvironment, there exists a statement which contains an if. For this\nif to be correctly evaluated, the boolean valuebneeds to evaluate to a true value.\nIf the premises are correct, the conclusion states thatStatement1 will be evaluated,\nand there may be a change in the store.\nenv\nv\n,store\nv\n⊢b→venv\nv\n⊢⟨IfbThenS,store⟩→store\n′\nenv\nv\n⊢⟨IfbThenS,store⟩→store\nwhereb→\nEx p\nff\nFigure 4.14:From slides [3]\nIn  Figure  4.14,  is  the  transition  rule  for  when  the  if-statement  will  not  be  evalu-\nated.The premises are the same however this is the case where it is denoted that\nthe value evaluates to false,  the conclusion being that there will be no change in\nthe store, as the if-statement will entirely be skipped.\nenv\nv\nstore\nv\n⊢b→venv\nv\n⊢⟨S;whilebThenS,store⟩→store\n′\n⟨whilebThenS,store⟩→store\n′\nwhereb→\nEx p\ntt\nFigure 4.15:From slides [3]\nIn  Figure  4.15,  one  can  see  the  behaviour  of  a  while  loop.   Similarly  to  the  if-\nstatement transition rule, the boolean expressionbneeds to evaluate to a value.  If\nthe premises are correct,  the conclusion states thatStatement1 will be evaluated,\nand there will be a change in the store.\nenv\nv\nstore\nv\n⊢b→venv\nv\n⊢⟨S;whilebThenS,store⟩→store\n′\n⟨whilebThenS,store⟩→store\nwhereb→\nEx p\nff\nFigure 4.16:From slides [3]\nIn  Figure  4.16,  the  premises  are  like  the  rule  before  it.   However,  as  this  is  the",
      "claims": []
    },
    {
      "number": 70,
      "originalText": "4.4.   Environment store model55\ntransition rule for when the while loop will not be evaluated as the value evaluates\nto false, the result being no change in the store.\n4.4.4    Type system\nIn   designing   the   CARL   programming   language,   establishing   a   robust   type\nsystem is essential.  This type system will define the semantics of statements and\noperations, with a particular emphasis on data types, which is also in accordance\nwith data types in the criteria section 3.2.  This section will elaborate on the rules\nfor variable declaration, type lookup, and type enforcement. Additionally, the text\nwill explain the environment in terms of a program being well-typed or ill-typed\nwithin CARL.\nWhen explaining the type rules, one must include the type environment.  It is im-\nportant not to confuse the type environment with the environment store model, as\nthey participate in entirely different processes. The type environment can be envi-\nsioned as a domain wherein variables and their corresponding types are stored.\n1E⊢x⇀T\n2E⊢x7→T\nFigure 4.17:From slides [3]\nLine  1  illustrates  that  a  lookup  might  not  always  give  a  result.   In  such  cases,\nCARL  should  give  an  error.   Line  2  explains  that  upon  declaring  a  variable,  its\ntype  is  mapped  to  that  variable  and  stored  in  the  environment.  Similarly  to  the\nenvironment store model, the processes of recording a type and retrieving a type\nfrom the environment are similar.\nAs depicted in Figure 4.2,  the formation rule for types shows that a type can be\none of three types:  Int, Float, or Bool.  These are the types that will be utilized to\nindicate the permissible types for use in certain expressions and statements within\nCARL.",
      "claims": [
        {
          "text": "establishing a robust type system is essential in designing the CARL programming language",
          "flag": false
        },
        {
          "text": "the type system will define the semantics of statements and operations",
          "flag": false
        },
        {
          "text": "this section will elaborate on the rules for variable declaration, type lookup, and type enforcement",
          "flag": false
        },
        {
          "text": "one must include the type environment when explaining the type rules",
          "flag": false
        },
        {
          "text": "the type environment can be envisioned as a domain wherein variables and their corresponding types are stored",
          "flag": false
        },
        {
          "text": "CARL should give an error if a lookup might not always give a result",
          "flag": false
        },
        {
          "text": "upon declaring a variable, its type is mapped to that variable and stored in the environment",
          "flag": false
        },
        {
          "text": "the processes of recording a type and retrieving a type from the environment are similar to the environment store model",
          "flag": false
        },
        {
          "text": "a type can be one of three types: Int, Float, or Bool",
          "flag": false
        }
      ]
    },
    {
      "number": 71,
      "originalText": "56Chapter 4.   Language design\n[Binary operations]\nE⊢a\n1\n: IntE⊢a\n2\n: Int\nE⊢a\n1\n⋆a\n2\n: Int\nE⊢a\n1\n: FloatE⊢a\n2\n: Float\nE⊢a\n1\n⋆a\n2\n: Float\nE⊢a\n1\n: FloatE⊢a\n2\n: Int\nE⊢a\n1\n⋆a\n2\n: Float\nE⊢a\n1\n: IntE⊢a\n2\n: Float\nE⊢a\n1\n⋆a\n2\n: Float\nFigure 4.18:Type rules for binary operators. From slides [3]\nThe type rules in Figure 4.18 illustrate the type rule for binary operators in CARL.\nThe first rule states that if expression1 and expression2 exist within the environ-\nment  and  are  evaluated  to  be  of  the  type  ’int’,  then  the  evaluation  of  the  binary\noperation can proceed.  This premise is also the basis for the other rules depicted\nin Figure 4.18, but with different types, as can be observed.  The type of the out-\ncome from these binary operations are specified in the conclusions.  Rules 3 and\n4 in the figure provide excellent examples of the orthogonality mentioned in the\nCriteria section 3.2, where operations are performed using two different types.\nE⊢a\n1\n: IntE⊢a\n2\n: Int\nE⊢a\n1\n..a\n2\n: Int\nE⊢a\n1\n: FloatE⊢a\n2\n: Float\nE⊢a\n1\n..a\n2\n: Float\nE⊢a\n1\n: FloatE⊢a\n2\n: Int\nE⊢a\n1\n..a\n2\n: Float\nE⊢a\n1\n: IntE⊢a\n2\n: Float\nE⊢a\n1\n..a\n2\n: Float\nFigure 4.19:Type rules for the random operator\nFigure 4.19 presents the type rule for the ’random’ operator in CARL. The premises\nof this operator are identical to the other binary operators, in that it evaluates to an\n’int’ if both expressions are ’int’s, or a ’float’ if any of the arguments are a ’float’.",
      "claims": [
        {
          "text": "expression1 and expression2 exist within the environment",
          "flag": false
        },
        {
          "text": "expression1 and expression2 are evaluated to be of the type 'int'",
          "flag": false
        },
        {
          "text": "the evaluation of the binary operation can proceed",
          "flag": false
        },
        {
          "text": "operations are performed using two different types",
          "flag": false
        },
        {
          "text": "the type of the outcome from these binary operations are specified in the conclusions",
          "flag": false
        }
      ]
    },
    {
      "number": 72,
      "originalText": "4.4.   Environment store model57\nE⊢a\n1\n: intE⊢a\n2\n: int\nE⊢a\n1\n⋆a\n2\n: Bool\nFigure 4.20:Star = ”=”, ”̸=”, ”<”, ”≤”, ”>”,or”≥” From slides [3]\nE⊢a\n1\n: floatE⊢a\n2\n: float\nE⊢a\n1\n⋆a\n2\n: Bool\nFigure 4.21:Star = ”=”, ”̸=”, ”<”, ”≤”, ”>”,or”≥” From slides [3]\nAs illustrated in Figure 4.20 and 4.21,  relational operators are featured in CARL.\nThe rule dictates that if the expressions are of the ’int’ or ’float’ type, it can then be\nsaid that the operation is valid and will return a value of type ’bool’.\nWith the type rules for expressions established, we can now proceed to define the\ntype rules for statements.\nE⊢b:boolE⊢S:ok\nE⊢IfbThenS:ok\nFigure 4.22:From slides [3]\nFigure 4.22 details the type rule for the if statement in CARL. The rule states that\nfor the statement to be evaluated correctly, there must be a boolean expression b\nthat is of the bool type.  Figure 4.22 also illustrates how boolean expressions are\nincorporated within the control structure of an if statement. The remaining control\nstatements  (if  else,  while)  in  the  context  of  type  rules  are  generic  and  similar  to\nthose in other programming languages.\nx̸∈dom(E)E⊢e:TE[x7→T]⊢S: ok\nE⊢varx:T=e;S: ok\nFigure 4.23:From slides [3]\nFigure 4.23 showcases the type rule for declaring variables within CARL. The rule\nstates that if the variable x is not already in the environment E, and if the expression",
      "claims": []
    },
    {
      "number": 73,
      "originalText": "58Chapter 4.   Language design\ne  also  has  type  T  in  the  environment,  then  the  variable  x  is  stored  within  the\nenvironment with its type.\nE(x) =TE⊢e:T\nE⊢x=e: ok\nFigure 4.24:From slides[3]\nFigure 4.24 illustrates assignment within CARL. It checks whether the variablex\nis already defined in the environmentEwith typeT, and whether the expression\nealso has typeTin the environment.  If these both apply, the assignmentx=eis\nwell-typed.\nWell typed vs Ill typed\nThe purpose of modelling a type system is to delineate what constitutes as well-\ntyped elements in CARL and what does not.  These rules can then be applied to\nanalyse whether a program is well-typed.  To demonstrate the functioning of the\nenvironment and to distinguish between a well-typed program, and one that is not\nin CARL, two illustrative programs were made.\n1var x:int = 2\n2var y:int = 3\n3var  result:int = x+y\nListing 4.14:Program Well typed\nIn Listing 4.14, one can view a program that is well-typed. On line 1, x is searched\nfor  in  the  environment  and,  not  being  found,  is  then  assigned  the  type  int  and\nstored  in  the  environment.   The  same  process  occurs  with  y  on  line  2.   On  line\n3,  there are two lookups in the Environment for result,  which is not yet present,\nso it is assigned the type int.  However, it is associated with the expression x + y,\nwhich needs to be evaluated to determine its legality.  Both x and y are found in\nthe Environment, confirming that this program is well-typed.\n1var x:int = 2\n2var y:bool =3\n3var  result:int = x+y\nListing 4.15:Program Ill typed",
      "claims": []
    },
    {
      "number": 74,
      "originalText": "4.4.   Environment store model59\nIn  Listing  4.15,  one  can  see  an  example  of  a  program  that  would  be  considered\nill-typed in CARL. Following the logic of the previously well-typed program, this\nexample fails when y is searched for in the environment and it is found to be of\ntype bool.  This operation would be illegal and should trigger an error, confirming\nthat this program is ill-typed.",
      "claims": [
        {
          "text": "one can see an example of a program that would be considered ill-typed in CARL",
          "flag": false
        },
        {
          "text": "the example fails when y is searched for in the environment",
          "flag": false
        },
        {
          "text": "y is found to be of type bool",
          "flag": false
        },
        {
          "text": "this operation would be illegal",
          "flag": false
        },
        {
          "text": "this program should trigger an error",
          "flag": false
        },
        {
          "text": "this program is ill-typed",
          "flag": false
        }
      ]
    },
    {
      "number": 75,
      "originalText": "",
      "claims": []
    },
    {
      "number": 76,
      "originalText": "Chapter 5\nImplementation\nNow  that  the  design  of  the  language  is  complete,  the  implementation  phase  of\nCARL  can  begin.   This  section  will  explore  the  various  dimensions  involved  in\nimplementing CARL, based on the design from the previous chapter.\nFirst, the type of translator for implementing CARL will be explored.  After this,\nthe step-by-step processes essential for translator implementation will be explored.\nThese steps encompass the lexer, parser, semantic analysis, and the evaluator/ex-\necutor.\nThe  complete  code  for  the  interpreter  can  be  found  onhttps://github.com/\nVinceAAU/P4.  A user-friendly guide for how to write scripts in the language can\nbe found in Appendix D.\n5.1    Choosing Between a Compiler, Transpiler or Interpreter\nOne  of  the  first  step  of  implementing  CARL  is  the  choice  of  choosing  between\nimplementing it as a compiler, transpiler or an interpreter.  CARL is a prototype,\nand  performance  is  not  one  of  the  important  aspects  to  focus  on.   It  is  made  to\nexplore  whether  domain  specific  languages  could  improve  the  development  of\nroguelike games.\nA compiler is a translator that would take CARL code and convert it to machine\ncode.    This  was  ruled  out,  as  it  would  require  becoming  proficient  in  writing\nmachine code.  Compilers do allow for language-specific optimisations, but there\nwere no immediately obvious optimisations that would not have been performed\nby a general-purpose compiler.\nA  transpiler  (also  called  a  source-to-source  compiler)  is  a  translator  that  would\ntake  CARL  code  and  convert  it  to  another  high-level  programming  language,\nfrom where it may then be compiled to machine code.  Much like with a compiler,\n61",
      "claims": [
        {
          "text": "the design of the language is complete",
          "flag": false
        },
        {
          "text": "CARL can begin",
          "flag": false
        },
        {
          "text": "the type of translator for implementing CARL will be explored",
          "flag": false
        },
        {
          "text": "the step-by-step processes essential for translator implementation will be explored",
          "flag": false
        },
        {
          "text": "these steps encompass the lexer, parser, semantic analysis, and the evaluator/executor",
          "flag": false
        },
        {
          "text": "the complete code for the interpreter can be found on https://github.com/VinceAAU/P4",
          "flag": false
        },
        {
          "text": "a user-friendly guide for how to write scripts in the language can be found in Appendix D",
          "flag": false
        },
        {
          "text": "CARL is a prototype",
          "flag": false
        },
        {
          "text": "performance is not one of the important aspects to focus on",
          "flag": false
        },
        {
          "text": "it is made to explore whether domain specific languages could improve the development of roguelike games",
          "flag": false
        },
        {
          "text": "a compiler was ruled out, as it would require becoming proficient in writing machine code",
          "flag": false
        },
        {
          "text": "compilers do allow for language-specific optimisations, but there were no immediately obvious optimisations that would not have been performed by a general-purpose compiler",
          "flag": false
        },
        {
          "text": "a transpiler is a translator that would take CARL code and convert it to another high-level programming language",
          "flag": false
        }
      ]
    },
    {
      "number": 77,
      "originalText": "62Chapter 5.   Implementation\nthis  would  require  a  code  generation  step,  but  it  would  be  with  a  more  familiar\nlanguage.\nAn interpreter would take CARL code and execute it directly, without translation\nto another language.  This approach does not include a code generation stage, but\nwould require emulating a program environment.  The figure 5.1 shows the stages\nof an interpreter.  The stages for a compiler/transpiler are similar, except that the\nexecution stage is replaced by a code generation stage.\nFigure 5.1:Interpreter phases\nUltimately,  as  performance  is  not  prioritised,  it  was  chosen  to  write  an  inter-\npreter.   It  was  judged  that  it  would  be  faster  to  develop  the  language  without\nthinking about code generation, allowing the project to focus on more important\ntasks.This  would  also  simplify  a  user’s  development  pipeline,   as  they  do\nnot  have  to  compile  a  script  to  be  able  to  use  it.To  some  extent,  it  would\nalso increase portability,  as the user would not need to ensure that their game is\nwritten in the same language as the one targetted by the potential CARL transpiler.",
      "claims": [
        {
          "text": "it would require a code generation step",
          "flag": false
        },
        {
          "text": "it would be with a more familiar language",
          "flag": false
        },
        {
          "text": "An interpreter would take CARL code and execute it directly, without translation to another language",
          "flag": false
        },
        {
          "text": "This approach does not include a code generation stage, but would require emulating a program environment.",
          "flag": false
        },
        {
          "text": "The stages for a compiler/transpiler are similar, except that the execution stage is replaced by a code generation stage",
          "flag": false
        },
        {
          "text": "Ultimately, as performance is not prioritised, it was chosen to write an interpreter",
          "flag": false
        },
        {
          "text": "It was judged that it would be faster to develop the language without thinking about code generation, allowing the project to focus on more important tasks",
          "flag": false
        },
        {
          "text": "This would simplify a user’s development pipeline, as they do not have to compile a script to be able to use it",
          "flag": false
        },
        {
          "text": "To some extent, it would also increase portability, as the user would not need to ensure that their game is written in the same language as the one targetted by the potential CARL transpiler",
          "flag": false
        }
      ]
    },
    {
      "number": 78,
      "originalText": "5.2.   Codebase setup63\n5.2    Codebase setup\nThe  interpreter  was  chosen  to  be  developed  in  the  Java  programming  language,\ndue  to  the  group’s  previous  familiarity  with  the  language,  and  its  mature  sup-\nport for various helpful tools, such as ANTLR. The build system used was Apache\nMaven.  Maven manages dependencies, and was configured to automatically gen-\nerate the parser and test the code before compilation. ANTLR 4 was used to gener-\nate the lexer and parser for the interpreter.  Unit tests were written using the JUnit\ntesting framework.\nVersion control of the code was done through Git.  When new features were de-\nveloped,  a new branch would be created for that feature.  These branches would\nnot be merged into the main branch until the feature was deemed complete.  The\ncode was hosted on GitHub, where measures were put into place to automatically\nenforce  these  guidelines.   In  particular,  code  could  not  be  merged  into  the  main\nbranch unless it fulfilled three requirements:  it must be approved by at least two\nproject contributors, it must successfully compile without errors, and all unit/in-\ntegration tests must pass.\n5.3    Generating the Lexer and Parser with ANTLR\nFor  the  lexical  analysis,  tokenization,  and  parsing  of  the  CARL  language,  it  was\nchosen to use ANTLR due to its power and simplicity.  Instead of hand-writing a\nlexer and parser, it was more efficient to employ ANTLR. This tool takes a grammar\nfile  (discussed  in  section  4.2.5)  and  generates  a  corresponding  lexer  and  parser.\nThis was integrated in the compilation process with Maven.\n1program : statement* EOF;\n2\n3statement\n4: assignment\n5| functionCall\n6| functionDefinition\n7| ifStatement\n8| whileLoop\n9| returnStatement\n10| structureDefinition\n11| importStatement\n12| variableDeclaration\n13| arrayDeclaration\n14| coordinateDeclaration\n15| methodCall\n16| propertyAssignment\n17;\nListing 5.1:Code snippet of ANTLR grammar file",
      "claims": []
    },
    {
      "number": 79,
      "originalText": "64Chapter 5.   Implementation\nThe  lexer  and  parsers  tokenise  the  input  source  code  and  generate  a  parse  tree\nfrom this.  ANTLR generates listener and visitor interfaces which can be used to\ntraverse the parse tree.  It was chosen to use the visitor interface, as it offers more\ncontrol and flexibility in regard to how to traverse the parse tree [16].\nAn example of a grammar rule defined in the grammar file is\narrayDeclaration.\nIt, along with some related rules, is displayed in Listing 5.2.\n1arrayDeclaration : ’var ’ IDENTIFIER  ’:’ legalArrayType\narrayOptionalIndex +;\n2\n3arrayOptionalIndex : ’[’ INT?  ’]’ ;\n4\n5legalArrayType :\n6’bool ’\n7| ’coord ’\n8| ’int ’\n9| ’string ’\n10| ’float ’\n11| IDENTIFIER ;\nListing 5.2:ThearrayDeclarationgrammar rule and others\nThelegalArrayTypedefines  all  the  types  that  the  array  can  have,  which  is  all\nthe types except an array type, to avoid recursion.  ThearrayOptionalIndexrule\nspecifies  an  array  size.   The  grammar  allows  the  size  to  be  left  blank,  ideally  to\nrepresent variable-length arrays (VLA’s), but this is disallowed later in the parser\nitself (due to VLA’s not being implemented yet).\nSimilar grammar rules have been written for all language constructs to be recog-\nnised by the parser, and as stated before, are used by ANTLR during compile time\nto generate the lexer and parser.  Then,  during runtime,  the generated lexer and\nparser can be used to create a parse tree:\n1CARLLexer  lexer = new  CARLLexer(CharStreams.fromStream(fileInput));\n2CommonTokenStream  tokens = new  CommonTokenStream(lexer);\n3CARLParser  parser = new  CARLParser(tokens);\n4\n5ParseTree  tree = parser.program ();\n5.4    Concrete Syntax Tree to an Abstract Syntax Tree\nThe parse tree generated by ANTLR is in the form of a concrete syntax tree (CST).\nWhile a CST can be traversed and evaluated immediately, it contains some unnec-\nessary syntactic information. An example of this CST could be seen in the previous\nchapter, on figure 4.1, which was generated for the following code:",
      "claims": []
    },
    {
      "number": 80,
      "originalText": "5.4.   Concrete Syntax Tree to an Abstract Syntax Tree65\n1if true {\n2var x: int = 3\n3return x\n4}\nThe AST abstracts some of the unnecessary information away and the same code\nwill genPerate an AST with a structure like the one seen in Figure 5.2.  The Cst-\nToAstVisitor  then  traverses  the  tree,  transforming  it  into  an  abstract  syntax  tree\nAST that encapsulates the program’s logic in a structured, hierarchical form.  This\ntransformation simplifies the manipulation of the parsed data, by aligning it more\nclosely with the language’s logical structure.\nProgram\nIf Statement\nExpression\nBoolean\nvalue : true\nBlock\n0\nVariable Declaration\nidentifier : x\ntype : int\nvalue : IntNode\nvalue : 3\n1\nReturn Statement\nvalue : Identifier\nx\nFigure 5.2:Abstract Syntax Tree\nExamples\nThis subsection gives concrete examples for the conversion from the CST to an AST.\nIt covers the assignment rule, the\nvisitAssignmentfunction, and the creation of\nAssignmentNodeandArrayAssignmentNode. Additionally, it explains how arrays\nare  handled  in  AST,  including  array  declaration  and  assignment,  with  detailed\nexamples and code snippets to illustrate the process.",
      "claims": [
        {
          "text": "The Concrete Syntax Tree abstracts some of the unnecessary information away.",
          "flag": false
        },
        {
          "text": "The same code will generate an AST with a structure like the one seen in Figure 5.2.",
          "flag": false
        },
        {
          "text": "The CST-To-AstVisitor traverses the tree, transforming it into an abstract syntax tree AST.",
          "flag": false
        },
        {
          "text": "The transformation simplifies the manipulation of the parsed data by aligning it more closely with the language's logical structure.",
          "flag": false
        },
        {
          "text": "Programs can be represented as a tree-like structure.",
          "flag": false
        },
        {
          "text": "If statements are a type of program construct that can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Expressions are a type of program construct that can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Boolean values can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Blocks are a type of program construct that can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Variable declarations are a type of program construct that can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Identifiers can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Types can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Values can be represented in an AST.",
          "flag": false
        },
        {
          "text": "Return statements are a type of program construct that can be represented in an AST.",
          "flag": false
        }
      ]
    },
    {
      "number": 81,
      "originalText": "66Chapter 5.   Implementation\nVariable Assignment\nVariable assignment is performed via the\nassignmentrule, which is written in the\ngrammar file as:\n1assignment : (IDENTIFIER | arrayAccess) ’=’ expression ;\nThis means that an assignment is defined as an identifier or an array access (for\nexample,foo[3][2]), followed by an equals sign, followed by an expression.\nOne of the files that ANTLR generates is theCARLBaseVisitorclass, containing\nvisitor  methods  for  every  rule  in  the  grammar.   These  can  be  overridden,  as  the\nCstToAstVisitorclass does withvisitAssignmentin Listing 5.3.\nThe method takes aCARLParser.AssignmentContextas an argument, which is an\nobject representing the assignment’s CST node.  That object will contain a method\nfor each part of the rule,  which will either return the CST node for that part,  or\nnull if the part is not there.  For example, if a variable is assigned to an identifier,\nthen\nctx.arrayAccess()will return null.\nThe code in Listing 5.3 uses this to check whether the left-hand side is an identifier\nor an array element.  If it’s an identifier, it creates the AST nodeAssignmentNode,\nand if it’s an array element, it creates the AST nodeArrayAssignmentNode.\n1@Override\n2public  AstNode  visitAssignment(CARLParser.AssignmentContext  ctx) {\n3AstNode  value = visit(ctx.expression ());\n4\n5if(ctx.IDENTIFIER ()!=null) {\n6return  new  AssignmentNode(\n7new  IdentifierNode(ctx.IDENTIFIER ().getText ()),\n8value);\n9} else if (ctx.arrayAccess ()!=null) {\n10return  new  ArrayAssignmentNode(\n11(ArrayAccessNode) visit(ctx.arrayAccess ()),\n12value);\n13} else {\n14throw  new  Error(\"Neither  an array  access  nor an  identifier\");\n15}\n16}\nListing 5.3:The visitAssignment method\nThe constructor for the\nAssignmentNodecreates a newAssignmentNodewith the\nidentifier node and value.  The constructor for the\nArrayAssignmentNodefetches\ninformation about the array’s identifier and the element’s indices, and associates it\nwith a value.\nThe  class  for  the  AST  nodeArrayAssignmentNodecan  be  seen  in  listing  5.4.   It\ncontains  an  identifier  (in  the  form  of  anIdentifierNode),  a  list  of  indices,  and\nthe value to be assigned.  Since nothing is evaluated at this stage, thevaluestays",
      "claims": [
        {
          "text": "Variable assignment is performed via the assignment rule",
          "flag": false
        },
        {
          "text": "The CARLBaseVisitor class contains visitor methods for every rule in the grammar",
          "flag": false
        },
        {
          "text": "The CstToAstVisitor class does with visitAssignment in Listing 5.3",
          "flag": false
        },
        {
          "text": "The method takes a CARLParser.AssignmentContext as an argument",
          "flag": false
        },
        {
          "text": "The object will contain a method for each part of the rule, which will either return the CST node for that part or null if the part is not there",
          "flag": false
        },
        {
          "text": "If it's an identifier, it creates the AST node AssignmentNode, and if it's an array element, it creates the AST node ArrayAssignmentNode.",
          "flag": false
        },
        {
          "text": "The constructor for the AssignmentNode creates a new AssignmentNode with the identifier node and value",
          "flag": false
        },
        {
          "text": "The constructor for the ArrayAssignmentNode fetches information about the array's identifier and the element's indices, and associates it with a value",
          "flag": false
        }
      ]
    },
    {
      "number": 82,
      "originalText": "5.4.   Concrete Syntax Tree to an Abstract Syntax Tree67\nas  an  AST  node  representing  the  unevaluated  expression  that  was  on  the  right-\nhand  side  of  the  assignment.   The@Getterannotation  is  a  feature  of  Lombok,\nwhich generates getter methods for the otherwise private class members.\n1@Getter\n2public  class  ArrayAssignmentNode  extends  AstNode {\n3final  private  IdentifierNode  identifier;\n4final  private  List <AstNode > indices;\n5final  private  AstNode  value;\n6public  ArrayAssignmentNode(IdentifierNode  identifier , List <AstNode\n> indices , ExpressionNode  value){\n7this.identifier = identifier;\n8this.indices = indices;\n9this.value = value;\n10}\n11public  ArrayAssignmentNode(ArrayAccessNode  arrayAccess , AstNode\nvalue) {\n12this.identifier = arrayAccess.getIdentifier ();\n13this.indices = arrayAccess.getIndices ();\n14this.value = value;\n15}\n16}\nListing 5.4:Array Declaration node\nIf Statements\nThe next example is aboutifstatements.\nTheIfStatementNodeclass is designed to hold and manage these lists of expres-\nsions and blocks. Once again, it provides constructors and getters that simplify the\ninitialization of the node and simplify access to its components, thereby enhancing\ninteraction with other parts of the interpreter.  The code for this class can be seen\nin Listing 5.4.\n1public  class  IfStatementNode  extends  AstNode {\n2List <BlockNode > blocks;\n3List <ExpressionNode > expressions;\n4\n5public  IfStatementNode(List <BlockNode > blocks ,\n6List <ExpressionNode > expressions) {\n7this.blocks = blocks;\n8this.expressions = expressions;\n9}\n10\n11// Getters  for ‘blocks ‘ and ‘expressions ‘ are  omitted\n12}\nThe  structure  of  anifstatement  is  described  by  theifStatementrule  in  the\nANTLR grammar:",
      "claims": []
    },
    {
      "number": 83,
      "originalText": "68Chapter 5.   Implementation\n1ifStatement : ’if’ expression  block\n2( ’else if’ expression  block )*\n3( ’else ’ block )? ;\nListing 5.5:The ANTLR grammar rule for anifstatements. Note that in the actual code, this is on a\nsingle line.\nThis is parsed with the\nvisitIfStatementmethod, seen on listing 5.6.\n1@Override\n2public  AstNode  visitIfStatement(CARLParser.IfStatementContext  ctx) {\n3List <ExpressionNode > expressionNodes = new  ArrayList <>();\n4for (CARLParser.ExpressionContext  exp : ctx.expression ()) {\n5if (exp.getChildCount ()  >= 3) {\n6AstNode  left;\n7if (exp.getChild (0)  instanceof  CARLParser.\nIdentifierContext) {\n8left = new  IdentifierNode(exp.getChild (0).getText ());\n9} else {\n10left = visit(exp.getChild (0));\n11}\n12AstNode  right;\n13if (exp.getChild (2)  instanceof  CARLParser.\nIdentifierContext) {\n14right = new  IdentifierNode(exp.getChild (2).getText ());\n15} else {\n16right = visit(exp.getChild (2));\n17}\n18RelationsAndLogicalOperatorNode  bin = new\nRelationsAndLogicalOperatorNode(left , right , exp.getChild (1).\ngetText ());\n19expressionNodes.add(new  ExpressionNode(bin));\n20} else {\n21expressionNodes.add(new  ExpressionNode(visit(exp)));\n22}\n23}\n24\n25List <BlockNode > blocks = new  ArrayList <>();\n26for (CARLParser.BlockContext  block : ctx.block ()) {\n27blocks.add(( BlockNode) visitBlock(block));\n28}\n29return  new  IfStatementNode(blocks , expressionNodes);\n30}\nListing 5.6:ThevisitIfStatementclass\nThe code begins by creating an empty list called\nexpressionNodes,  intended to\nstore  each  conditional  expression  for  the  ’if’s,  ’else-if’s,  and  ’else’s.    It  iterates\nthrough  each  expression  in  the  statement.   Inside  each  iteration,  it  checks  how\nmany children the expression has.\nIf it has three or more, it is assumed to be a binary operation.  Between line 6 and\n11, the left operator is found.  Between line 12 and 17, the right operator is found.",
      "claims": []
    },
    {
      "number": 84,
      "originalText": "5.5.   Semantic checker69\nThe purpose of doing this is so that the left and right nodes are of a useful type.\nAnRelationsAndLogicalOperatorNodeis created from this data, and is added to\ntheexpressionNodeslist.\nOtherwise, the expression is visited and added to the list of expressions.\nThen, a list of blocks is declared. Each block in theifstatement is iterated through,\nvisited to create a\nBlockNode, and added to the list of blocks.\nFinally, anIfStatementNodeis created from the list of blocks and list of expression\nnodes.  It is worth noting that while it is not explicitly specified whether the last\nclause  is  anelseorelse ifstatement,  it  can  be  inferred  by  comparing  the\namount of blocks and expression nodes; a statement ending inelsewill have one\nfewer expressions than blocks.\nIn  the\nvisitWhileLoopmethod  of  theCstToAstVisitorclass,  the  approach  is\nsimilar  to  thevisitIfStatementmethod  but  adjusted  for  while  loops.   It  eval-\nuates  the  loop’s  conditional  expression,  creating  anExpressionNode,  and  pro-\ncesses the loop’s body into aBlockNode.  These components are combined into a\nWhileLoopNode, which integrates the loop’s condition and actions into the AST.\n5.5    Semantic checker\nAs  mentioned  in  section  4.3,  there  is  some  amount  of  type  enforcement.    The\nprocess  of  type  enforcement  and  semantic  checking  takes  place  in  the  semantic\nchecker.    The  semantic  checker  has  three  main  jobs  to  take  care  of:   checking\nvariable declaration and usage, to ensure that variables are declared before usage;\nchecking  if  the  typing  of  operations  is  legal,   through  the  rules  described  in\nsection 4.4.4;  and ensuring that function calls agree with the function’s arity and\nparameter types.\nThe  semantic  checker  in  CARL  also  performs  additional  tasks,  such  as  ensur-\ning  that  non-void  functions  include  a  return  statement  and  that  the  return  type\nmatches  the  declared  function  type;  if  a  function  is  invoked  on  the  right-hand\nside of a variable assignment, verifying that the type returned by the function call\nmatches  the  type  of  the  variable  being  assigned;  and  crucially,  generating  infor-\nmative error messages.  These messages detail the errors detected by the semantic\nchecker and present them to the user. If an error is thrown by the semantic checker,\nthe evaluator/executor process will not take place.\n5.5.1    Variable Declaration\nThe semantic checker has its own environment, completely separate from the eval-\nuator/executors, as outlined in the type system section. This environment focuses\non  checking  the  existence  of  variable  types  and  therefore,  only  stores  identifiers",
      "claims": []
    },
    {
      "number": 85,
      "originalText": "70Chapter 5.   Implementation\nand their types.\n1private  void  visitVariableDeclaration(VariableDeclarationNode  node) {\n2try {\n3boolean  found = scopes.getFirst ().containsKey(node.\ngetIdentifier ().toString ());\n4for (int i = scope.size(); i>=0; i--) {\n5if (scopes.get(i).containsKey(node.getIdentifier ().\ntoString ())) {\n6found = true;\n7}\n8}\n9if (!found) {\n10String  identifier = node.getIdentifier ().toString ();\n11Type  variableType = getType(node.getType ());\n12AstNode  ass = node.getValue ();\n13Type  assignmentType = getType(ass);\n14if (variableType  ==  assignmentType) {\n15Type  Type_we_save_in_E_table = variableType;\n16scopes.getLast ().put(node.getIdentifier ().toString (),\nType_we_save_in_E_table);\n17} else {\n18error_handler(\"Tried to  asssign  Type:\" +\nassignmentType + \" to the  variable:\" + identifier + \" that  has  the\ntype:\" + variableType + \" And  that is   iligal\");\n19}\n20} else {\n21error_handler(\"variable \" + node.getIdentifier () + \"\nalready  exists\");\n22}\n23} catch (Exception e) {\n24error_handler(e.getMessage ());\n25}\n26\n27}\nListing 5.7:Variable Declaration\nIn the code listing 5.7, one can see the code responsible for saving new identifiers\nand their corresponding  types.  Lines 3-8  search for the identifier of  the variable\nthat is being declared in the scopes.  This is done by looping through all existing\nscopes,  as  seen  in  line  4.   If  the  identifier  is  found,  the\nfoundboolean  in  line\n6  is  set  totrue.   In  line  9,  the  code  diverges  into  two  paths:  if  the  variable  is\nfound,  the  code  proceeds  to  line  21,  where  an  error  is  printed  by  the  error  han-\ndler, informing the user that they attempted to declare an already existing variable.\nThe  second  path  that  starts  at  line  10  begins  the  semantic  checking.    The  first",
      "claims": []
    },
    {
      "number": 86,
      "originalText": "5.5.   Semantic checker71\nstep is obtaining the variableType, as seen in line 11.  The type is resolved by the\ngetType function, which will be explained later. In line 13, the assigned type is also\nresolved.  Lines  14-16  compare  the  two  types;  if  they  match,  the  variable  and  its\ntype are stored in the environment’s scope.  If not, an error message is generated\non line 18.\n5.5.2    Get Type\nRegarding  the  semantic  checker,  it  was  important  to  have  a  way  to  attempt  to\nresolve the type of a node, even for nodes that didn’t inherently have a type.\n(a)  Roots found(b)  Types resolved\nFigure 5.3:Get Type\nFigure  5.3  illustrates  how  the  types  of  variable  declarations  are  resolved  and\nchecked.    To  resolve  the  nodes’  types,  the\nGetTypefunction  recurses  until  it\nreaches a leaf node containing the type.  After each leaf has been found, the type\ninformation  can  be  received  by  the\nVariable declaration,  which  can  see  that\nthe  two  types  agree.  Because  the  declared  and  assigned  types  are  the  same,  the\nsemantic checker can accept the variable declaration.\n(a)  Roots found(b)  Variable dec fails\nFigure 5.4:Failed type check",
      "claims": []
    },
    {
      "number": 87,
      "originalText": "72Chapter 5.   Implementation\nFigure 5.4 illustrates the semantic checker’s ability to detect errors.  Once again, in\nsubfigure 5.4(a), it finds the leaves of the tree.  As it resolves upwards in subfigure\n5.4(b), on theBinary operation node, it runs into a problem. This is because the\nsemantic checker verifies whether the resolved types for the types for\nBool node\nandInt nodeare valid types for the binary operation. In this case they are not, so\nit is marked as invalid. This causes a cascading effect, where each layer above gets\nmarked as invalid until it reaches the root.  Consequently, the variable declaration\nfails.  It is worth noting that the semantic checker throws an error at the first place\nan operation fails (in this casebinary operation node,  which helps to identify\nwhere the errors originate.\n1public  Type  getType(Object  node) {\n2Type  type = Type.UNKNOWN;\n3if (node  instanceof  IntNode) {\n4type = Type.INT;\n5} else if (node  instanceof  BinaryOperatorNode) {\n6type = binaryOperatorTypeCheck (( BinaryOperatorNode) node);\n7}\n8return  type;\n9}\nListing 5.8:Heavily simplified\ngetTypefunction.\nListing  5.8  shows  a  example  of  the\ngetTypefunction.   The  example  is  highly\nsimplified, with all cases besides\nIntNodeandBinaryOperatorNoderemoved. In\nline 2, the default return value is declared.  Starting at line 3, the code checks the\ntype of the object.  If the object is one of the leaf nodes, for example anIntNode ,\nthe returned type is set to INT. However, if the object is an instance of an internal\nnode,  such  asBinaryOperatorNode ,  then  a  specialised  type  checking  function\nmust be called, in this casebinaryOperatorTypeCheck() . Within that function, the\nbinary operator   is type-checked,  and the result’s type is resolved and returned.\nOnce the semantic check of the node is completed, its type is returned in line 8.\n5.5.3    Error handler\nThe semantic checker’s errors should be as informative as possible.  To help with\nthis, a function was created to generate error messages.",
      "claims": [
        {
          "text": "the semantic checker can detect errors",
          "flag": false
        },
        {
          "text": "once again, the semantic checker finds the leaves of the tree",
          "flag": false
        },
        {
          "text": "the semantic checker verifies whether the resolved types for the types for Bool node and Int node are valid types for the binary operation",
          "flag": false
        },
        {
          "text": "the semantic checker throws an error at the first place an operation fails",
          "flag": false
        },
        {
          "text": "the example is highly simplified, with all cases besides IntNode and BinaryOperatorNode removed",
          "flag": false
        },
        {
          "text": "if the object is one of the leaf nodes, for example an IntNode, the returned type is set to INT",
          "flag": false
        },
        {
          "text": "if the object is an instance of an internal node, such as BinaryOperatorNode, then a specialised type checking function must be called",
          "flag": false
        },
        {
          "text": "the binary operator is type-checked, and the result's type is resolved and returned",
          "flag": false
        },
        {
          "text": "once the semantic check of the node is completed, its type is returned",
          "flag": false
        }
      ]
    },
    {
      "number": 88,
      "originalText": "5.5.   Semantic checker73\n1public  void  errorHandler(String  errorMessage) {\n2thereWasAnError = true;\n3System.err.println(\"Error \" + errorNumber);\n4errorNumber = errorNumber + 1;\n5System.err.println(errorMessage);\n6}\nListing 5.9:Error handler\nIn  Listing  5.9  above,  you  can  see  the  code  behind  the  error  handler.   The  error\nhandler  is  invoked  throughout  the  semantic  checker.   In  line  1,  you  can  see  that\nit  takes  a  string  parameter,  which  is  the  error  message.    In  line  2,  a  boolean\nthereWasAnErroris set to true to signal to the main function that the evaluator\nshould not run because there was an error in the Semantic checker.  Line 3 prints\nthe error number, which helps identify the order in which things failed. Finally, in\nline 5, the actual error message is printed.\nThe actual messages would look like the following in the terminal.\nError 1\nTried to assign Type:STRING to the variable:p that has the type:INT And that is\nillegal\nError 2\nWrong types for binary operation:INT And:nej:STRING\nError 3\nVariable ’sej’ has not been defined yet.\nFigure 5.5:Semantic checker errors\n5.5.4    If & while\nConditional loops and if-else statements are also handled in the semantic checking,\nalthough only if-statements will be explained and illustrated here, as they function\nsimilarly.",
      "claims": [
        {
          "text": "the error handler is invoked throughout the semantic checker.",
          "flag": false
        },
        {
          "text": "it takes a string parameter, which is the error message.",
          "flag": false
        },
        {
          "text": "a boolean thereWasAnError is set to true to signal to the main function that the evaluator should not run because there was an error in the Semantic checker.",
          "flag": false
        },
        {
          "text": "line 3 prints the error number, which helps identify the order in which things failed.",
          "flag": false
        },
        {
          "text": "the actual error message is printed in line 5.",
          "flag": false
        },
        {
          "text": "the actual messages would look like the following in the terminal.",
          "flag": false
        },
        {
          "text": "Error 1 Tried to assign Type:STRING to the variable:p that has the type:INT And that is illegal.",
          "flag": false
        },
        {
          "text": "Error 2 Wrong types for binary operation:INT And:nej:STRING.",
          "flag": false
        },
        {
          "text": "Error 3 Variable ‘sej’ has not been defined yet.",
          "flag": false
        },
        {
          "text": "conditional loops and if-else statements are also handled in the semantic checking.",
          "flag": false
        },
        {
          "text": "if-statements will be explained and illustrated here, as they function similarly.",
          "flag": false
        }
      ]
    },
    {
      "number": 89,
      "originalText": "74Chapter 5.   Implementation\n1public  void  visitIfStatement(IfStatementNode  node) {\n2Type  expression = Type.VOID;\n3for (int i = 0; i < node.getExpressions ().size(); i++) {\n4expression = getType(node.getExpressions ().get(i).getNode\n());\n5if (expression  != Type.BOOLEAN) {\n6//Error  handle\n7}\n8}\n9for (int i = 0; i < node.getBlocks ().size(); i++) {\n10HashMap <String , Type > localETable = new  HashMap <>();\n11scopes.add(localETable);\n12visitBlockNode(node.getBlocks ().get(i));\n13scopes.remove(localETable);\n14}\n15}\nListing 5.10:Semantic checker for if-statements\nListing  5.10  demonstrates  how  the  Semantic  checker  handles  if-statements.    If-\nstatements can contain multiple blocks of statements and multiple conditions. This\nmeans that eachifandelse ifstatement condition needs to be checked along\nwith  their  respective  blocks.   Since\nIfStatementNodeholds  lists  for  both  blocks\nand expressions, each can be looped over and checked.  Inside the if-statement, a\nnew  scope  is  declared.  While-loops  function  similarly.  However,  the  check  only\nneeds to be done once since there is only one block and one condition to be evalu-\nated.\n5.5.5    Structs & functions\nAnother check that is handled is the struct declarations, seen below.",
      "claims": []
    },
    {
      "number": 90,
      "originalText": "5.5.   Semantic checker75\n1public  void  visitStruct(StructureDefinitionNode  node) {\n2String  typeStruct = node.getType ().toString ();\n3if (! structTypes.containsKey(typeStruct)) {\n4if (typeStruct.equals(\"enemy\")) {\n5String  identifier = node.getIdentifier ().toString ();\n6if (! tileInformationEnemy.containsKey(identifier)) {\n7HashMap <String , Type > localETable = new  HashMap <>();\n8scopes.add(localETable);\n9List <VariableDeclarationNode > declarations = node.\ngetVariableDeclarations ();\n10struct_variable_declarion_failed = false;\n11for (VariableDeclarationNode  declaration :\ndeclarations) {\n12visitVariableDeclarationforStructs(declaration);\n13}\n14if (! struct_variable_declarion_failed) {\n15tileInformationEnemy.put(identifier , localETable);\n16structTypes.put(identifier , Type.ENEMY);\n17}\n18struct_variable_declarion_failed = false;\n19scopes.remove(localETable);\n20} else {\n21// Error\n22}\n23}\n24}\n25}\nListing 5.11:Struct semantic checker\nListing  5.11  illustrates  the  struct  checking  process  in  the  semantic  checker  class.\nThe  parameternodeis  utilised  to  access  specific  elements,   exclusive  to  the\nStructureDefinitionNodeclass.\nThe   primary   functionality   of   thevisitStructmethod   is   to   verify   if   the\nstruct  already  exists  within  the\ntileInformationEnemyhashMap  in  line  6.    If\nit  does,  an  error  is  handled  in  line  21.   Otherwise,  a  new  local  scope  is  created.\nvisitVariableDeclarationforStructscalls the variable declaration method for\neach variable declared in the struct in lines 11-14,  storing both the variables and\nstruct  in  their  respective  tables  in  lines  16  and  17,\ntileInformationEnemyand\nstructTypes.\n1HashMap <String , Type > typeOfReturnFunction;\n2HashMap <String , List <Type >> functionParameters;\nListing 5.12:Function Hash Map semantic checker",
      "claims": []
    },
    {
      "number": 91,
      "originalText": "76Chapter 5.   Implementation\nThe approach for functions definition and function call in type checker similarly\ninvolves utilising Hash Maps. One hash maps is ued for the function’s return type\nand another hash map is used for its parameters 5.12. The primary functionality of\nfunctions definition method and function call method is very similar to the struct\ncheck.   They  verify  if  functions  exist  and  whether  their  parameters  are  declared\ncorrectly when defined and used correctly when called.  The main difference lies\nin the check for the type for the functions,  which need to match the return type\nspecified in the block of the function definition method.\n1public  void  visitReturnNode(ReturnStatementNode  node) {\n2Type  returnType = getType(node.getReturnValue ());\n3Type  activeFunction = typeOfReturnFunction.get(\ncurrentActiveFunction);\n4if (Objects.equals(currentActiveFunction , \"\")) {\n5//Error  handle\n6}\n7if (returnType  !=  activeFunction) {\n8//Error  handle\n9}\n10}\nListing 5.13:semantic checker for return statements\nListing 5.13 illustrates how the return type is checked against the expected return\ntype of the function.  If the return type matches the correct type for the function,\nthen no error occur.\nWith  the  implementation  logic  of the  semantic  checkers  generally  explained  and\nlaid out, one can begin to explain the process of evaluation and execution.\n5.6    Evaluation/Execution\nNow  that  the  semantic  checker  has  completed  its  process,  the  next  phase  of  im-\nplementation  will  be  presented.   This  involves  showing  the  implementing  of  the\nevaluation  and  execution  of  statements.   In  this  section,  the  implementation  of\nevaluating values, executing statements, and other noteworthy aspects of the im-\nplementation will be outlined.\n5.6.1    Dynamic Scope\nDynamic scoping plays an important role in how variables are accessed and modi-\nfied in nested programming structures. ThegetVariable5.14 method effectively",
      "claims": []
    },
    {
      "number": 92,
      "originalText": "5.6.   Evaluation/Execution77\ndemonstrates this concept by starting its search for variables from the most recently\nactivated scope, ensuring that the most local version of a variable is used.\n1public  AstNode  getVariable(IdentifierNode  node) {\n2for (int i = scopes.size() - 1; i  >= 0; i--) {\n3if (scopes.get(i).containsKey(node.getIdentifier ())) {\n4return  scopes.get(i).get(node.getIdentifier ());\n5}\n6}\n7...\n8}\nListing 5.14:Locating a variable in the nearest scope using dynamic scoping\nIn the listing 5.14 on line 2,  the listing iterates through the stack of scopes,  from\nthe  most  recent  to  the  first  scope  for  variables.    It  checks  each  scope  to  see  if\nit  contains  the  variable  identified  by\nnode.getIdentifier().   If  the  variable  is\nfound, its value is retrieved and returned immediately and stops the search.\nIn  the  following  code  example,   the  dynamic  scoping  mechanism,   explained\nthrough the\ngetVariablemethod, significantly influences the program behaviour\nand output.\n1var x: int = 0\n2var y: int = 42\n3\n4fn p() -> void {\n5x= x + 3\n6}\n7fn q() -> void {\n8p()\n9}\n10fn main() -> int {\n11x = 20\n12print(x)\n13var x : int = 9\n14\n15q()\n16y = x\n17return y\n18}\n19\n20print(\" Before  main\")\n21var v : int = main()\n22print(\" efter  Main\")\n23print(y)\n24print(v)\nIn the code example, global variables x and y are initially set to 0 and 42, respec-\ntively.   Within  the  main()  function,  a  new  local  scope  is  created  when  x  is  rede-",
      "claims": []
    },
    {
      "number": 93,
      "originalText": "78Chapter 5.   Implementation\nclared,  shadowing  the  global  x  within  this  function.   Each  function,p(),q(),\nandmain(), creates its own scope, influencing variable accessibility.\nInmain(),  x  is  updated  to  20  (line  11)  and  then  locally  redeclared  and  set  to  9\n(line 13), shadowing the global x.  Actions affecting x occur at these lines.  When\nq()is called (line 15) and subsequently callsp(),p()adds 3 to the local x (line\n5), theoretically increasing it to 12.\ny = x(line 16) assigns the value of the localx, now 12, to y, and then prints v\n(also 12, which is x) in line 24.\nThis  example  demonstrates  how  dynamic  scoping  allows  functions  likep()to\nmodify the most recently accessed instance of a variable in their execution context,\nhighlighting variable visibility and modifications based on their scope as managed\nby\ngetVariable.\n5.6.2    Builtin functions\nBuiltin functions work the same way as any other function call does in CARL, with\nan exception that they do not return anything, and that they do not create a new\nscope.\n1public  AstNode  visit(FunctionCallNode  node) {\n2if (node.getFunctionName ().toString ().equals(\"print\")) {\n3InbuildClasses.print(node , scopes);\n4} else if (node.getFunctionName ().toString ().equals(\"\ngenerateMap\")) {\n5InbuildClasses.generateGrid(node , scopes ,\ntileInformationWall);\nListing 5.15:Interpreter file line 421-426 showing how builtin functions are called lines. From 426 to\n444 are repeated pattern\nIn  the  listing  5.15  you  can  see  the  current  builtin  functions,  which  areprint,\ngenerateMapthe   rest   of   the   functions   which   follow   the   same   pattern   are\ngenerateRooms,generateSpawns,printMap, andwriteToFile.  All the before\nmentioned functions call a different function inside ofInbuildClasses.javafile.\nThis was done in order to have a slightly smallerevaluatorExecutor.javafile,\nand it made sense to separate them.",
      "claims": [
        {
          "text": "Each function, p(), q(), and main(), creates its own scope, influencing variable accessibility.",
          "flag": false
        },
        {
          "text": "Dynamic scoping allows functions like p() to modify the most recently accessed instance of a variable in their execution context.",
          "flag": false
        },
        {
          "text": "Variable visibility and modifications are based on their scope as managed by getVariable.",
          "flag": false
        },
        {
          "text": "Builtin functions work the same way as any other function call does in CARL, with an exception that they do not return anything, and that they do not create a new scope.",
          "flag": false
        }
      ]
    },
    {
      "number": 94,
      "originalText": "5.6.   Evaluation/Execution79\n1public  static  void  generateGrid(FunctionCallNode  node , Stack <\nHashMap <String , AstNode >> scopes , HashMap <String , HashMap <String ,\nAstNode >> tileInformationWall) {\n2if (node.getArguments ().size() == 2) {\n3ArrayList <Integer > indices = new  ArrayList <>();\n4indices.add((( IntNode) node.getArguments ().get(0)).\ngetValue ());\n5indices.add((( IntNode) node.getArguments ().get(1)).\ngetValue ());\n6ArrayNode  map = new  ArrayNode(new  TypeNode(\"string\"),\nindices);\n7scopes.getFirst ().put(\"map\", map);\n8if (! tileInformationWall.isEmpty ()) {\n9var  key = tileInformationWall.keySet ().toArray ()[0];\n10StringNode  symbol = (( StringNode) tileInformationWall.\nget(key).get(\"symbol\"));\n11for (int i = 0; i < (( IntNode) node.getArguments ().get\n(0)).getValue (); i++) {\n12for (int j = 0; j < (( IntNode) node.getArguments ()\n.get(1)).getValue (); j++) {\n13map.set(symbol , i, j);\n14}\n15}\n16} else {\n17for (int i = 0; i < (( IntNode) node.getArguments ().get\n(0)).getValue (); i++) {\n18for (int j = 0; j < (( IntNode) node.getArguments ()\n.get(1)).getValue (); j++) {\n19map.set(new  StringNode(\"w\"), i, j);\n20}\n21}\n22}\n23} else {\n24throw  new  RuntimeException(\"invalid  argument  count  in\ngenerateGrid\");\n25}\n26}\nListing 5.16:InbuildClasses file line 41-66 showing the builtin function calledgenerateMap\nIn listing 5.16 on line 2 it is first checked that the correct amount of arguments has\nbeen passed in the function call,  if it is correct we proceed else throw a runtime\nexception.   From  line  3  to  7  it  creates  a  global  variable  calledmap.   In  line  8  it\nchecks if the user of CARL has defined a wall already.  If the user has, it picks the\nfirst  one  and  fill  the  map  with  the  respective  symbol.   Else  it  does  the  same  but\nwith symbolw.",
      "claims": []
    },
    {
      "number": 95,
      "originalText": "80Chapter 5.   Implementation\n1generateMap (20 ,25)\n2generateRooms (3,5,7)\n3generateCorridors ()\n4generateSpawns ()\n5writeToFile ()\nListing 5.17:a .carl file showing minimal amount of functions required to generate a map\nYou can make an entire map with only builtin functions.  The minimal amount of\ncode required, looks like the listing 5.17 this outputs a JSON file calledmap.json\nthe file will be similar to the listing 3.1 as the final output was modelled after the\ninitial one.\n5.6.3    Struct like\nAnother somewhat important aspect of CARL is its struct like containers for vari-\nables.  There exists 4 different containersroom,wall,floor, andenemythose\nwork the same as variable types, the only difference is after equals you make a new\nobject syntactically.",
      "claims": [
        {
          "text": "You can make an entire map with only builtin functions.",
          "flag": false
        },
        {
          "text": "The minimal amount of code required looks like listing 5.17.",
          "flag": false
        },
        {
          "text": "This outputs a JSON file called map.json.",
          "flag": false
        },
        {
          "text": "The file will be similar to the listing 3.1 as the final output was modelled after the initial one.",
          "flag": false
        }
      ]
    },
    {
      "number": 96,
      "originalText": "5.6.   Evaluation/Execution81\n1public  AstNode  visit(MethodCallNode  node) {\n2HashMap <String , HashMap <String , AstNode >> list;\n3switch (node.getPropertyAccessContext ().getList ()) {\n4case \"enemy\" -> list = tileInformationEnemy;\n5case \"wall\" -> list = tileInformationWall;\n6case \"floor\" -> list = tileInformationFloor;\n7case \"room\" -> {\n8return  roomCall(node);\n9}\n10default  -> throw  new  RuntimeException(\"list  doesnt  exist\")\n;\n11}\n12if (node.getPropertyAccessContext ().getIdentifiers ().get (0).\ntoString ().equals(\"size\")) {\n13return  new  IntNode(list.size());\n14} else if (node.getPropertyAccessContext ().getIdentifiers ().\nget (0).toString ().equals(\"get\")) {\n15if ((( ArgumentListNode) node.getValue ()).getList ().get (0)\ninstanceof  IntNode) {\n16int  index = (( IntNode) (( ArgumentListNode) node.\ngetValue ()).getList ().get(0)).getValue ();\n17if (index < list.size()) {\n18var  key = list.keySet ().toArray ()[index];\n19return  list.get(key).get(node.getIdentifierNode ().\ntoString ());\n20} else {\n21throw  new  RuntimeException(\"out of  bounds\");\n22}\n23} else {\n24throw  new  RuntimeException(\"parameter  must be an int\")\n;\n25}\n26}\n27throw  new  RuntimeException(\"method  call  went  wrong\");\n28}\nListing 5.18:interpreter line 66-93 showing method calls on structs\nIn the listing 5.18 in line 2 a local variable gets created called list.  In line 3-10 a\nvariable  gets  assigned  to  the  correct  hashMap,  orroomCallgets  called  instead\nas  rooms  work  a  little  differently.   This  is  because  rooms  are  not  a  hashMap  of\nhashMaps but a list of hashMaps so it is treated slightly differently.  If the list is\nnot found, in line 10 a runtime exception is thrown.  Afterwards, we check if it is\nany of the 2 existing method calls line 12-14.  if it is\n.sizewe return the size of\nthe array as a new IntNode line 13.  Else if it is.getwe make the hashMap to an\narray and return the according element based on an int provided in the parameter\nline 14-19.  This is not always an optimal way of doing it, as hashMap makes the\norder alphabetical because the key is a string, and not in the order of declaration.",
      "claims": []
    },
    {
      "number": 97,
      "originalText": "82Chapter 5.   Implementation\nBased upon on CARL’s use case, this should be fine as.getis meant to be used\nwith  the..operator  which  returns  a  random  integer.   By  this  it  is  meant  that\n.getis only meant for being used with..operator.  If a specific struct needs to\nbe accessed, the type of the struct followed by the identifier of the struct is used,\nsuch as\nenemy.orcenemy being the type and orc being the identifier.\n5.6.4    Summarizing of the Implementation\nIn  the  implementation,  all  the  MVP  features  were  implemented.   The  process  of\ndeveloping an interpreter for CARL was outlined by going through the processes\nand presenting the more interesting code parts and logic. With the implementation\nphase done, one can now move on to the testing phase, where the interpreter was\ntested.",
      "claims": [
        {
          "text": "Based upon CARL’s use case, this should be fine as",
          "flag": false
        },
        {
          "text": "getis is meant to be used with the..operator which returns a random integer.",
          "flag": false
        },
        {
          "text": "getis only meant for being used with..operator.",
          "flag": false
        },
        {
          "text": "If a specific struct needs to be accessed, the type of the struct followed by the identifier of the struct is used",
          "flag": false
        }
      ]
    },
    {
      "number": 98,
      "originalText": "Chapter 6\nTesting\nThis  section  delves  into  the  testing  of  CARL  implementation.   It  will  outline  the\nuse  of  black  box  and  white  box  testing,  along  with  the  reasoning  behind  these\napproaches.  Additionally, the code coverage achieved during testing will be pre-\nsented.  Both unit testing and integration testing were employed throughout this\nphase for a possible more comprehensive evaluation.\n6.0.1    Purpose of testing\nA goal of testing CARL were to ensure that some of the important lines of code\nacted according to what was expected of them, given a certain input and context.\nAdditionally,   a  goal  of  testing  was  to  ensure  that  building  further  upon,   or\nchanging the existing code would not ruin the existing functionality.  With these\ngoals in mind, the possibilities of testing could now be explored.\nTo gain a thorough understanding of the code, white box testing could be a pos-\nsibility,  because  the  standard  of  white  box  testing  is  to  ensure  that  it  tests  every\npossible execution flow of the code and verifies that it performs as expected.  This\nis in contrast to black box testing, where only the output given a certain input is\ntested[29].\nThe  main  testing  philosophy  used  was  black-box  testing.   This  is  because  black\nbox tests are faster to write, enabling broader code coverage.  The tradeoff is that\nchecks for edge cases might not be quite as comprehensive as if the code’s internal\nstructure was taken into account.\n6.0.2    Code coverage\nWith the testing philosophy in place, the tests were created.  This approach is also\nclearly reflected in the code coverage.\n83",
      "claims": []
    },
    {
      "number": 99,
      "originalText": "84Chapter 6.   Testing\nFigure 6.1:The code coverage of various files in the project\nIn Figure 6.1,  one can see the test code coverage analysis made by IntelliJ IDEA.\nHere,  the  focus  should  be  on  the  tests  made  by  the  team,  which  cover  every\nfile  and  folder  except\nCARLVisitor,CARLListener,CARLLexer,CARLPARSER,\nCARLBaseVisitor,  andCARLBaseListnerwhich  are  generated  by  ANTLR.  The\ninteresting aspect, is that not everything is tested.  The rationale is that not every\npart of the code was of equal importance for CARL. Hence, there was a focus on\nmostly creating tests for the parts that were thought to be of more important.\n6.1    Unit test\nUnit  testing  focuses  on  the  smallest  parts  of  an  application,  examining  an  indi-\nvidual function or section of code.  By isolating each component and testing them\nseparately, it could help ensure that bugs are caught before they escalate into more\nsignificant issues in the system [1].\nThis   section   specifically   addresses   unit   testing   of   the   Abstract   Syntax   Tree\nnodes   to   ensure   they   are   constructed   according   to   the   specified   require-\nments   of   CARL.   The   following   listings\nVariableDeclarationNodeTestand\ntestGetAstNodeValueIntFloatillustrates unit testing of the node classes.  Given\nthe similarity of the node construct tests, only tow example of this will be shown.\n1@Test\n2void  testVariableDeclarationNodeConstructor () {\n3IdentifierNode  identifier = new  IdentifierNode(\"x\");\n4TypeNode  type = new  TypeNode(\"int\");\n5IntNode  value = new  IntNode(\"100\");\n6",
      "claims": [
        {
          "text": "the test code coverage analysis made by IntelliJ IDEA",
          "flag": false
        },
        {
          "text": "not every part of the code was of equal importance for CARL",
          "flag": false
        },
        {
          "text": "unit testing focuses on the smallest parts of an application, examining an individual function or section of code",
          "flag": false
        },
        {
          "text": "by isolating each component and testing them separately, it could help ensure that bugs are caught before they escalate into more significant issues in the system",
          "flag": false
        },
        {
          "text": "the unit test specifically addresses unit testing of the Abstract Syntax Tree nodes to ensure they are constructed according to the specified requirements of CARL",
          "flag": false
        }
      ]
    },
    {
      "number": 100,
      "originalText": "6.2.   Integration test85\n7VariableDeclarationNode  node = new  VariableDeclarationNode(\nidentifier , type , value);\n8\n9assertSame(identifier , node.getIdentifier (), \"Identifier  should\nmatch\");\n10assertSame(type , node.getType (), \"Type  should  match\");\n11assertSame(value , node.getValue (), \"Value  should  match\");\n12}\nListing 6.1:Variable declaration node test\nListing6.1illustratestheprocessoftestingtheconstructionofa\nVariableDeclarationNode.The  JUnit  framework  was  used  during  the  test-\ning  phase  of  the  interpreter.In  this  example,  JUnit  is  used  to  annotate  the\nmethod  with,\n@Testin  line  1,  an  annotation  that  denotes  that  the  method  is\na  test  case.Within  this  test  method  from  2-7,  instances  ofIdentifierNode,\nTypeNode,   andIntNodeare  instantiated  to  represent  the  components  of  a\nvariable  declaration.   TheassertSamemethod  from  line  9-11,  is  used  to  assert\nthat theIdentifierNode,TypeNode, andIntNodeinstances retrieved from the\nVariableDeclarationNodeare  the  same  as  the  ones  initially  created,  thereby\nvalidating that the node’s constructor correctly assigns these components.\n1\n2public  void  testGetAstNodeValueIntFloat () {\n3AstNode  left = new  FloatNode(\"3.0\");\n4AstNode  right = new  IntNode(\"2\");\n5AstNode  node = BinaryOperatorNode.getAstNodeValue(left , right , \"+\"\n);\n6Assertions.assertEquals(\"5.0\", node.toString ());\n7Assertions.assertInstanceOf(FloatNode.class , node);\n8}\nListing 6.2:Binary operation test\nListing   6.2   demonstrates   the\ntestPerformOperationIntmethod   within   the\nBinaryOperatorNodeTestclass.   Here,  the  method  tests  a  binary  operation  be-\ntween the different data types, an integer and a float, by callingperformOperation\nfromBinaryOperatorNode.   UsingassertInstanceOf,  it  validates  that  the  re-\nturnednodeis  of  aFloatNodeclass,  confirming  the  expected  node  type,  and\nassertEqualsensures thatnodehas the correct value for the specific operation.\n6.2    Integration test\nIntegration testing is an important phase in software development, that tests how\ndifferent units,  modules,  or components of an application interact.  Although in-",
      "claims": []
    },
    {
      "number": 101,
      "originalText": "86Chapter 6.   Testing\ndividual modules may be developed by different programmers and function cor-\nrectly on their own,  integration testing ensures they operate together seamlessly.\nThis form of testing is important because it identifies issues that occur when units\ninteract with each other, which is not possible in unit testing.  Integration testing,\nwhich  can  include  different  tools,  checks  that  integrated  components  meet  func-\ntional, performance, and reliability requirements.  By catching any errors early in\nthe  development  process,  integration  testing  can  help  maintain  system  integrity\nand reduce debugging costs at later stages[2].\n6.2.1    Integration tests of the semantic checker\nIn  this  subsection,  the  integration  tests  generally  involve  feeding  lines  of  code\nthrough the phases up to and focusing on the semantic checker.\nChecking variable declaration and usage\nOne  of  the  Semantic  checkers  responsibilities  would  be  to  ensure  that  variables\ncould not be redeclared within the same scope, but also that variables should be\ndeclared before its usage. Therefore, the test shown in listing 6.3 was made.\n1void  testTypeCheker1 () {\n2String  code = \"\"\"\n3var  array: int [3][3]\n4var  array: int[v][3]\n5\"\"\";\n6AstNode  astTree = treemaker(code);\n7String  correct_error = \"\"\"\n8Error 1\n9could  not  find  the  variable v\n10Error 2\n11Tried to  declare  the  array:array  but  argument: 0 is of\ntype:UNKNOWN  and  should  be:INT\n12Error 3\n13Identifier:array  is  alredy  used , rename  it\n14\"\"\";\n15semanticChecker.visitor(astTree);\n16String  terminal_Errors = normalizeOutput ();\n17assertEquals(correct_error.trim(), terminal_Errors);\n18}\nListing 6.3:Array test\nIn  this  listing,  an  example  of  an  integration  test  that  tests  the  semantic  process\nof  array  declarations  in  CARL.  Lines  2-5  declare  the  code  written  in  CARL  that\nis  tested  in  this  test.   Line  3  presents  an  example  of  a  correct  array  declaration,\nin  contrast  to  line  4  which  shows  a  semantically  incorrect  array  declaration  that\nshould  generate  errors.   On  line  7-14,  one  can  read  the  expected  errors  that  the\nsemantic checker process should print.",
      "claims": []
    },
    {
      "number": 102,
      "originalText": "6.2.   Integration test87\nThetestTypeCheker1()function contains two array declarations to test the type\nchecker  from  lines  2-5.   The  AST  are  generated  on  line  6,  then  on  line  15,  the\nsemantic checker examines the generated AST for errors.  Line 16 takes the errors\nprinted to the console and stores them in the variable. This output is then asserted\non line 17 to match the expected errors.  This test was designed with the focus of\nverifying that errors are printed and in the correct order, given those specific lines\nof code.\n6.2.2    Type checking\nAnother  responsibility  of  the  semantic  checker  is  to  ensure  that  operations  are\nperformed between compatible types. To test this, the following test was created.\n1void  testTypeCheker47 () {\n2String  code = \"\"\"\n3var  integer:int =20\n4var  test_string:string=\"string\"\n5var  result:int = integer+test_string\n6\"\"\";\n7AstNode  astTree = treemaker(code);\n8\n9String  correct_error = \"\"\"\n10Error 1\n11Wrong  types  for  binary  operation:INT:integer  And:test_string:\nSTRING\n12Error 2\n13Tryied  to  asssign  Type:UNKNOWN  to the  variable:result  that  has  the\ntype:INT And  that is hella  iligal\n14\"\"\";\n15typeChecker.visitor(astTree);\n16String  terminal_Errors = normalizeOutput ();\n17assertEquals(correct_error.trim(), terminal_Errors);\n18}\nListing 6.4:Binary operation test\nThe  listing  6.2.2  shows  an  example  of  one  of  the  integration  tests,  which  checks\nwhether the semantic checker correctly prints an error if the code contains illegal\noperations.  Lines 2-6 declare the code that will be used in the test.  Lines 3-4 cor-\nrectly declare two variables.  However, on line 5, an illegal operation combination\nof an integer and a string is \"coded\". The semantic checker is run with the created\ncode  on  line  15,  and  the  output  printed  to  the  console  is  captured  on  line  16.\nFinally, on line 17, it compares the expected errors with the actual errors displayed\nin the console.\nThe rest of the tests for the semantic checker are very similar, including semantic\nchecks for functions, which also test scenarios where, given certain lines of code,",
      "claims": []
    },
    {
      "number": 103,
      "originalText": "88Chapter 6.   Testing\nthe semantic checker either will or will not print errors in a prescribed order.\n6.2.3    Integration tests of the Evaluator/Executor\nThetestingFunctiontest  case  is  essential  for  validating  the  function  called\ncalculatewithin the program, by ensuring its proper execution and interaction\nwith the broader system.  This test has a self-contained piece of code to define a\nfunction that returns a constant value, calls the function, and prints the result. The\ntest starts by creating a code snippet that defines a function and uses it, then sets\nup  a  simulated  execution  environment  with  an  InputStream  to  process  the  code\nthrough the lexer and parser.  These components translate the textual code into a\nparse tree, a hierarchical representation of the program’s structure.\n1public  void  testingFunction ()  throws  Exception {\n2String  code = \"\"\"\n3fn  calculate () -> int {\n4return  42\n5}\n6var  result: int = calculate ()\n7print(result)\n8\"\"\";\n9\n10...\n11\n12assertEquals(\"42\".trim(), outContent.toString ().trim(), \"Expected\nthe  output  to be 42\");\n13}\nListing 6.5:TestingFunction\nThis AST serves as the input for the interpreter, which traverses the AST, interprets\nthe nodes, executes the calculate function, and captures the output.  The assertion\nat the end of the test,\nassertEquals, is important as it ensures that the execution\nof the\ncalculatefunction returns the expected output, which is \"42\".  This asser-\ntion confirms the end-to-end functionality from parsing to execution, highlighting\nthe ability of the system to handle function definitions and executions accurately.\nThe  test  is  integral  for  assuring  the  correctness  and  reliability  of  the  program’s\nfunction execution mechanism.\nThe\ntestingIfElseChaintest is important for showing complex conditional logic\nwithin  the  program,  ensuring  the  correct  execution  paths  are  followed  based  on\nspecific  conditions.   This  test  constructs  a  scenario  involving  nested  if-else  state-\nments, which is important for testing the program’s logical control flow.  The test\nstarts with a string of code that defines variables and sets up a chain of conditional\nstatements.  The test employs an InputStream to simulate the input environment.",
      "claims": []
    },
    {
      "number": 104,
      "originalText": "6.2.   Integration test89\nThis stream inputs the code into the CARLLexer and CARLParser, transforming it\ninto a parse tree; a hierarchical representation organized by syntax.\n1public  void  testingIfElseChain ()  throws  Exception {\n2String  code = \"\"\"\n3var x : int = 1\n4var y : int = 0\n5if x > 5 {\n6y = 1\n7} else if x < -5 {\n8y = 2\n9} else {\n10y = 3\n11}\n12print(y)\n13\"\"\";\n14....\n15\n16Interpreter  interpreter = new  Interpreter ();\n17interpreter.visit(astRoot);\n18\n19assertEquals(\"3\".trim(), outContent.toString ().trim(),\n20\"Expected  the  output  to be 3 because x does  not  meet  the  other\nconditions  and  therefore , y should  be set to 3.\");\n21}\nListing 6.6:If code\nAn  AST  is  generated  off  the  code  and  The  interpreter  then  executes  this  AST,\nparticularly  focusing  on  evaluating  the  conditional  logic  and  ensuring  that  the\ncorrect branches are executed based on the given conditions.  The test concludes\nwith an assertion that checks the printed output against the expected result,  \"3\",\nconfirming  that  the  application  correctly  handles  multiple  conditional  pathways\nand assigns the correct values based on the evaluated conditions.\n6.2.4    Summary of tests\nThe  testing  of  various  processes  ensured  that  parts  of  the  interpreter  that  were\ntested  would  actually  behave  consistently  given  the  same  test  parameters.  From\nthis,  the  test  writer  will  be  able  to  extrapolate  more  precisely  which  cases  the\ninterpreter can handle and which it cannot. However, testing only shows that code\nperforms in a certain way under specific circumstances, and therefore there could\nbe unforeseen cases that are not accounted for.",
      "claims": []
    },
    {
      "number": 105,
      "originalText": "90Chapter 6.   Testing\n6.3    Acceptance Testing\nIn this section,  the acceptance tests will be presented.  The reasoning behind the\ndevelopment of these tests will be discussed, their goals, and how the tests them-\nselves are structured.\n6.3.1    Objective\nThe objective of the acceptance test is to create the prototype JSON file mentioned\nin  the  3.1.   The  goal  of  this  is  to  demonstrate  that  the  prototype  output  can  be\ngenerated with a program made in CARL. It was decided that there should be three\nacceptance tests.  One test involves a program made using the built-in functions,\nthe second one is conducted without them, and the last one being a hybrid between\nthe first two.  This approach was chosen to demonstrate that the prototype could\nbe successfully created.\nTest with Built-in Functions\n1generateMap (20 ,25)\n2generateRooms (3,5,7)\n3generateCorridors ()\n4generateSpawns ()\n5writeToFile ()\n6\nListing 2:Acceptance Test: with builtin functions\nThis test focuses on efficiency and simplicity of CARL’s built-in functions to gen-\nerate a game map.  With only a few lines of code, the map can be created and ex-\nported, showcasing the language’s ability to streamline complex tasks into straight-\nforward commands. The built-in functions cover essential map creation steps such\nas generating the map, rooms, corridors, and spawns, ultimately writing the gen-\nerated map to a file.  This approach demonstrates the language’s primary goal of\nreducing development time and effort for indie developers by providing high-level\nabstractions for common tasks.\nTest without Built-in Functions\nThe test involves manually coding the entire map generation process without utilis-\ning the built-in functions other than\nwriteToFile()to print the format to a JSON\nfile.   This  comprehensive  code  demonstrates  the  flexibility  and  power  of  CARL,",
      "claims": []
    },
    {
      "number": 106,
      "originalText": "6.3.   Acceptance Testing91\nallowing developers to have full control over the map creation process.  By manu-\nally specifying each step, from initialising the map to placing rooms and corridors,\ndevelopers can tailor the map generation process to their specific needs and pref-\nerences.  This test also highlights the language’s capability to handle detailed and\nintricate algorithms, ensuring that it can accommodate various levels of complexity\nrequired by different game designs.\nThe  code  without  builtin  functions  is  mostly  the  same  as  the  Java  code  that  is\nbehind the builtin functions but written within the boundaries of the CARL lan-\nguage.  Given the length of the code listings of CARL, the code was not shown in\nthis section,  but can still be seen in the appendix C. In the appendix C the lines\n1-12 are equivalent to the first line in listing 2 and are the same 1–12 lines as shown\nin the hybrid approach 5.  Line 13-68 is line 2 of listing 2.  Line 70-102 is line 3 of\nlisting 2.\n1var  playerX : int = room.get(toRooms).x .. room.get(toRooms).x + room.\nget(toRooms).roomWidth\n2var  playerY : int = room.get(toRooms).y .. room.get(toRooms).y + room.\nget(toRooms).roomHeight\n3map[playerX ][ playerY] = \"p\"\n4\nListing 3:Acceptance Test: without builtin functions\nLastly,  in  line  104-106,  a  player  is  spawned  in  the  last  room,  which  is  shown\nin  listing  3.This  is  a  little  different  from  the\ngenerateSpawnsfunction,  as\ngenerateSpawnsalso has the capability of spawning enemies based on difficulty.\nSpawning of enemies is not implemented in this test.  Lastly, the builtin function\nwriteToFileis used to write everything to map.json file.\nHybrid with Built-in and custom\nA hybrid approach is also possible, where you replace some of the code with CARL\ncode and use Built-in functions for the stuff that the user does not want to bother\nwith.",
      "claims": [
        {
          "text": "allowing developers to have full control over the map creation process.",
          "flag": false
        },
        {
          "text": "By manually specifying each step, from initialising the map to placing rooms and corridors, developers can tailor the map generation process to their specific needs and preferences.",
          "flag": false
        },
        {
          "text": "This test also highlights the language's capability to handle detailed and intricate algorithms, ensuring that it can accommodate various levels of complexity required by different game designs.",
          "flag": false
        },
        {
          "text": "The code without builtin functions is mostly the same as the Java code that is behind the builtin functions but written within the boundaries of the CARL language.",
          "flag": false
        },
        {
          "text": "Given the length of the code listings of CARL, the code was not shown in this section, but can still be seen in the appendix C.",
          "flag": false
        },
        {
          "text": "In the appendix C the lines 1-12 are equivalent to the first line in listing 2 and are the same 1–12 lines as shown in the hybrid approach 5. Line 13-68 is line 2 of listing 2. Line 70-102 is line 3 of listing 2.",
          "flag": false
        },
        {
          "text": "Line 104-106, a player is spawned in the last room, which is shown in listing 3.",
          "flag": false
        },
        {
          "text": "This is a little different from the generateSpawns function, as generateSpawns also has the capability of spawning enemies based on difficulty.",
          "flag": false
        },
        {
          "text": "Spawning of enemies is not implemented in this test.",
          "flag": false
        }
      ]
    },
    {
      "number": 107,
      "originalText": "92Chapter 6.   Testing\n1var  size : int = 20\n2var  map : string[size][size]\n3var i : int = 0\n4var j : int = 0\n5while i < size{\n6j   = 0\n7while j < size {\n8map[i][j] = \"w\"\n9j = j+1\n10}\n11i = i+1\n12}\n13generateRooms (3,5,7)\n14generateCorridors ()\n15\n16var  playerX : int = room.get(0).x .. room.get(0).x + room.get(0).width\n17var  playerY : int = room.get(0).y .. room.get(0).y + room.get(0).\nheight\n18map[playerY ][ playerX] = \"p\"\n19writeToFile ()\n20\nListing 4:Acceptance Test: with builtin functions\nThe test line 1-12 is the same one as mentioned earlier3. Here is the skeleton of the\nmap is generated in CARL language which is equivalent to what thegenerateMap\ndoes and in the test without built-in functions, but it is here for demonstration pur-\nposes. Then two built-in functions used to generate rooms and corridors. Lastly, a\nplayer is placed in the first room instead of the last one, which is what the built-in\nfunction\ngenerateSpawnsdoes.\nUnity\nTo  ensure  the  map  generation  can  be  integrated  into  a  game  development  envi-\nronment,  all  the  acceptance  tests  are  conducted  within  Unity.   This  ensures  that\nthe output from CARL can be seamlessly used in a widely adopted game engine,\ndemonstrating CARL’s practical utility in real-world game development scenarios.",
      "claims": []
    },
    {
      "number": 108,
      "originalText": "6.3.   Acceptance Testing93\n1void  Start()\n2{\n3ProcessStartInfo  startInfo = new  ProcessStartInfo ();\n4startInfo.WorkingDirectory = Application.dataPath;\n5startInfo.FileName = \"java\";\n6startInfo.Arguments = \"-jar  carl.jar \" + carlFile;\n7startInfo.CreateNoWindow = true;\n8startInfo.UseShellExecute = false;\n9startInfo.RedirectStandardOutput = true;\n10startInfo.RedirectStandardError = true;\n11Process  process = new  Process ();\n12process.StartInfo = startInfo;\n13\n14process.Start ();\n15process.WaitForExit ();\n16ParseAndSpawn ();\n17}\n18\nListing 5:Acceptance Test: with builtin functions\nIn  this  Unity  script,  the  CARL  interpreter  is  executed  as  a  Java  process  to  run\nthecarlFilewhich  is  a  serialized  field  at  the  top  which  lets  you  specify  what\nCARL  file  you  want  to  run.    Once  the  CARL  interpreter  is  run,  it  produces  a\nmap.json file that is then parsed and used to spawn game elements within Unity.\nThis integration demonstrates how CARL’s output can be utilized in a real game\nengine, ensuring that the language’s utility extends beyond theoretical use cases.\nComparison and Results\nThe results of all three tests are expected to be consistent,  producing valid game\nmaps in the desired format. The success of these acceptance tests shows that CARL\nmeets its objectives, providing both ease of use through built-in functions and flex-\nibility through manual coding capabilities. This dual approach ensures that CARL\ncan cater to a wide range of developers, from beginners seeking quick solutions to\nadvanced users needing detailed control over their game development process.",
      "claims": [
        {
          "text": "CARL interpreter is executed as a Java process to run carlFile",
          "flag": false
        },
        {
          "text": "CARL file is a serialized field at the top which lets you specify what CARL file you want to run",
          "flag": false
        },
        {
          "text": "Once the CARL interpreter is run, it produces a map.json file that is then parsed and used to spawn game elements within Unity",
          "flag": false
        },
        {
          "text": "This integration demonstrates how CARL's output can be utilized in a real game engine, ensuring that the language's utility extends beyond theoretical use cases",
          "flag": false
        },
        {
          "text": "The results of all three tests are expected to be consistent, producing valid game maps in the desired format",
          "flag": false
        },
        {
          "text": "The success of these acceptance tests shows that CARL meets its objectives",
          "flag": false
        },
        {
          "text": "CARL provides both ease of use through built-in functions and flexibility through manual coding capabilities",
          "flag": false
        },
        {
          "text": "This dual approach ensures that CARL can cater to a wide range of developers, from beginners seeking quick solutions to advanced users needing detailed control over their game development process",
          "flag": false
        }
      ]
    },
    {
      "number": 109,
      "originalText": "",
      "claims": []
    },
    {
      "number": 110,
      "originalText": "Chapter 7\nDiscussion\nThe  discussion  will  outline  the  project’s  fulfilment  of  the  language  design  and\nimplementation.  The language design will focus on the criteria,  structure,  scope\nrules of CARL and the choices made. Furthermore, it will discuss the choices made\nduring the implementation phase,  and possible improvements.  Additionally,  the\nfulfilment of the MoSCoW requirements from section 3.3 will be discussed.\n7.1    Language design\n7.1.1    Criteria fulfilment\nMaking CARL user-friendly and tailored to its domain was a priority, as described\nin section 3.2.  With the diverse approaches to creating a roguelike game, ensuring\nease  in  map  creation  and  algorithm  development  was  crucial,  so  simplicity  was\nkey.    CARL  keeps  things  simple  with  basic  constructs,  like  using  if-statements\nfor conditions and while-loops for repetition, which function similarly to switch-\nstatements  and  for-loops  but  are  easier  to  understand.The  team  also  opted\nfor  clarity  by  skipping  redundant  options  like  ’++’  for  incrementing  or  ’–’  for\ndecrementing,  finding  that  a  straightforward  assignment  does  the  job  just  as\neffectively.\nCARL  also  offers  the  flexibility  to  perform  operations  between  different  data\ntypes,   enabling  calculations  between  integers  and  floats,  while  limiting  com-\npatibility  with  certain  combinations  such  as  strings  and  other  data  types.   This\nfeature enhances code readability and writability,  permitting operations between\nnumerical values while preventing interactions between dissimilar data types.\nIn   CARL,   enforcing   data   types   was   considered   crucial   for   enhancing   read-\nability and writability.  Unlike JavaScript, where data types are not strict, in CARL\n95",
      "claims": [
        {
          "text": "The language design will focus on the criteria, structure, scope rules of CARL and the choices made.",
          "flag": false
        },
        {
          "text": "Making CARL user-friendly and tailored to its domain was a priority.",
          "flag": false
        },
        {
          "text": "Ensuring ease in map creation and algorithm development was crucial, so simplicity was key.",
          "flag": false
        },
        {
          "text": "CARL keeps things simple with basic constructs, like using if-statements for conditions and while-loops for repetition.",
          "flag": false
        },
        {
          "text": "The team also opted for clarity by skipping redundant options like '+' for incrementing or '-' for decrementing.",
          "flag": false
        },
        {
          "text": "A straightforward assignment does the job just as effectively.",
          "flag": false
        },
        {
          "text": "CARL also offers the flexibility to perform operations between different data types, enabling calculations between integers and floats.",
          "flag": false
        },
        {
          "text": "This feature enhances code readability and writability, permitting operations between numerical values while preventing interactions between dissimilar data types.",
          "flag": false
        },
        {
          "text": "Enforcing data types was considered crucial for enhancing readability and writability.",
          "flag": false
        },
        {
          "text": "Unlike JavaScript, where data types are not strict, in CARL data types are enforced.",
          "flag": false
        }
      ]
    },
    {
      "number": 111,
      "originalText": "96Chapter 7.   Discussion\nit was opted for explicit typing to make code easier to understand.  The primitive\ndata types included in CARL areint,float,string, andbool. The reason for\nincluding only a few data types is that CARL is designed to be a domain-specific\nlanguage,  and  additional  types  were  deemed  unnecessary.   Additionally,  struct\ntypes were incorporated to provide more specificity, which is especially useful in\nroguelike  creation,  as  it  allows  for  easily  defining  enemies  and  other  spawnable\nentities with structs.\nThe  syntax  of  CARL  was  intentionally  kept  very  similar  to  other  well-known\nlanguages  like  C,  as  to  make  it  more  intuitive  for  new  users  to  write  in  CARL.\nExamples  of  this  were  the  choices  of  keywords  such  as  ’while’  for  while  loops,\n’int’  for  defining  integers,  and  ’print’  for  printing  statement.   This  also  makes  it\nvery clear what kind of statement is being used in the code.\nCARL   was   designed   with   abstraction   in   mind,   allowing   the   invocation   of\npredefined  functions.This  was  important  to  CARL’s  development,  as  it  en-\nables  users  to  write  less  code  with  the  helper  functions,  such  as  simplifying\nmap  creation  or  formatting  JSON  output.By  leveraging  this  feature,   code\nbecomes  more  readable,  writable,  and  comprehensible.    Initially,  the  plan  was\nto  implement  the  predefined  functions  as  methods,  such  that  a  user  could  call\ncreateMap.createAlgorithmin  order  to  encapsulate  complex  logic  behind  a\nsimpler  interface,  but  it  was  eventually  deemed  unnecessary,  so  that  approach\nwas abandoned.  While this approach was abandoned, it is still possible to invoke\npredefined functions in it of themselves.\n7.1.2    Control structures and operators\nAs mentioned earlier, certain constructs were intentionally left out from CARL be-\ncause it was believed they weren’t essential for achieving the same functionality.\nHowever, there might have been advantages to including the option for some ad-\nditional constructs,  such as switch statements,  as it could potentially have led to\ncleaner  code.   Nevertheless,  adding  them  might  have  complicated  the  language\nand  made  it  more  difficult  for  users  to  understand.   Furthermore,  implementing\nthese features would have required more time for functions that were deemed less\nimportant, which was another factor in the decision not to include some of these\nconstructs. Certain operations were spelled out for clarity, such as changing ’&&’ to\n’AND’ and ’||’ to ’OR’. Although other operator changes were considered, retain-\ning their original syntax was chosen to avoid complicating the code with lengthy\nkeywords.",
      "claims": []
    },
    {
      "number": 112,
      "originalText": "7.2.   Implementation97\n7.1.3    Function scope\nAdditionally,  as  mentioned  in  section  4.4.1,  CARL  was  designed  to  have  mixed\nscope  rules,  incorporating  dynamic  scope  variables  and  static  function  scope.\nThis design choice was made was because it was believed that static scoping for\nfunctions would be easier for users of CARL to understand.\nHowever, while it is possible to create functions within functions, it is not possible\nto  shadow  declarations  of  functions.   Consequently,  no  scope  rules  for  functions\nhave been implemented. This issue was discovered late in the coding process, and\nwas prioritised below other aspects of the project, leading to a lack of development\nof the issue.\nIt would be possible to implement static function scope in the code base.  Specifi-\ncally, each time a function is declared, it would be added to the current function\nscope.  To locate the correct function, the program would iterate through the func-\ntion  scopes  from  the  active  scope  from  when  it  was  declared,  and  continues  to\nmove out to the outermost declarations until it finds the required function.  This\nlookup uses the scope hierarchy established at compile-time, meaning it searches\nbased on the function’s static context rather than the runtime call context [36].\n7.2    Implementation\n7.2.1    Language Selection in Interpreter Development\nThe current interpreter for CARL is developed using Java, a language which allows\nfor easy integration of custom code and plugin-like functionality.  These features\nmake Java particularly valuable for projects that may require frequent updates or\nexpansions  through  user-contributed  modules.   Python,  one  of  the  most  widely\nused programming languages, relies on C for its core implementation. This under-\nscores the benefits of leveraging a lower-level language to optimize performance\nand resource management in language interpreters.\nDespite  the  advantages  of  Java,  there  are  compelling  reasons  to  consider  rewrit-\ning  the  interpreter  in  a  more  performance-oriented  language  such  as  C,  C++,  or\nRust.   These  languages  offer  better  efficiency  and  are  better  suited  for  handling\nthe  low-level  operations  often  required  in  interpreters.   The  transition  to  a  more\nefficient language could potentially improve execution speed and reduce resource\nconsumption, aligning with the performance demands of more complex map gen-\neration tasks in roguelike games.\nRewriting  the  interpreter  also  presents  an  opportunity  to  apply  better  program-\nming practices and make structural improvements based on lessons learned from\nthe current implementation such as, visitor pattern, better code organisation, better",
      "claims": []
    },
    {
      "number": 113,
      "originalText": "98Chapter 7.   Discussion\ntesting, and static scoping rules.  This process would not only improve the archi-\ntecture of the interpreter but also make sure it is more maintainable and scalable.\nHowever, the decision to move away from Java should consider the broader acces-\nsibility for new contributors.  The ease of understanding and modifying Java code\ncan  significantly  lower  the  barrier  to  entry  for  community  contributions,  poten-\ntially fostering a more active and inclusive development environment,  compared\nto C.\n7.2.2    Robustness In CARL\nRobustness  is  also  important  for  catching  any  errors  in  an  interpreter.    CARL\nis  generally  robust,   incorporating  checks  in  its  type  checker  and  additional\nvalidations  in  the  evaluator.   However,  error  handling  in  the  AST  visitor  class  is\ncurrently limited due to uncertainty regarding whether to centralise checks in the\nsemantic checker or introduce error handling in the AST visitor as well. Enhancing\nerror handling in the AST visitor class could significantly help CARL’s robustness.\nOn  top  of  this,   while  CARL  does  provide  users  with  error  messages  and  a\nsequence of errors,  it lacks information about the specific line in the code where\nthe  error  occurred.    Implementing  this  feature  could  greatly  enhance  the  user\nexperience,  particularly  when  dealing  with  larger  codebases,  as  users  currently\ncannot  quickly  find  out  where  exactly  their  errors  are.    This  could  have  been\nincluded by keeping the start and end line from the CST in the AST. It is currently\nlost under conversion to AST\nAnother  area  for  improvement  in  CARL  is  improving  the  internal  type  sys-\ntem of the interpreter.  Currently, the interpreter uses a type called ’ASTNode’ to\nencapsulate  all  the  node  classes.  It  is  used  both  as  a  superclass  for  node  classes\nand  as  a  data  type  passed  around  between  the  classes  and  methods.   This  lacks\ninherent  meaning  beyond  ensuring  it  is  of  type  ’ASTNode’.    While  checks  are\nperformed  on  node  types  during  interpretation,  enforcing  correct  types  during\nimplementation could significantly have enhanced CARL’s robustness.\nThe choice of ANTLR\nAnother important aspect of the implementation was the decision to use ANTLR4\nfor the interpreter. This choice was primarily influenced by the familiarity of a team\nmember with this tool and the team’s preference for using Java for development.\nThe choice was further supported by the project’s lack of need for high execution\nspeed, allowing the use of Java despite its relatively slower performance compared\nto languages like C or C++.\nWhile ANTLR offers several advantages,  such as compatibility with various pro-",
      "claims": []
    },
    {
      "number": 114,
      "originalText": "7.3.   Fulfilment of requirements99\ngramming languages and the ability to generate CSTs, it also presented challenges.\nANTLR  version  4  switched  its  default  behaviour  to  generating  CSTs  instead  of\nASTs, which posed difficulties and required a conversion into an AST. Despite this\nchallenge, ANTLR allowed for faster code generation by eliminating the need for\nmanually writing a parser, enabling the team to allocate more time to other tasks. If\nthe parser had been manually written, it would also mean that any changes made\nto the CFG would also necessitate changes to the parser.\n7.3    Fulfilment of requirements\nThis section in the discussion focuses the fulfilled requirements, while the unful-\nfilled requirements will be mentioned in future work 8.\n7.3.1    Must haves\nMMust have\nM1The language must support data creation/management✓\nM2The program must allow the data to be written to a file in a serialised\nformat, such as JSON, XML, or CSV\n✓\nM3The language must contain at least one predefined algorithm for gen-\nerating the outline of a level, walls and floors\n✓\nM4The language must support the ability to write and use custom level-\ngeneration algorithms\n✓\nM5Language must support the procedural placement of objects✓\nTable 7.1:Must haves\nData Creation and Management (M1)\nThe interpreter is capable of creating data and custom data types, including arrays\nand  structures,  which  facilitates  dynamic  data  handling  and  supports  complex\ndevelopment requirements.\nData Serialization (M2)\nThe  interpreter  supports  exporting  data  to  a  JSON  format,  which  meets  the  re-\nquirement of supporting at least one popular serialized format.  Although Unity\nlacks  comprehensive  native  JSON  support,  this  is  generally  circumvented  by  de-",
      "claims": [
        {
          "text": "ANTLR version 4 switched its default behaviour to generating CSTs instead of ASTs",
          "flag": false
        },
        {
          "text": "ANTLR allowed for faster code generation by eliminating the need for manually writing a parser",
          "flag": false
        },
        {
          "text": "the team could allocate more time to other tasks",
          "flag": false
        },
        {
          "text": "any changes made to the CFG would also necessitate changes to the parser",
          "flag": false
        },
        {
          "text": "the language must support data creation/management",
          "flag": false
        },
        {
          "text": "the program must allow the data to be written to a file in a serialized format, such as JSON, XML, or CSV",
          "flag": false
        },
        {
          "text": "the language must contain at least one predefined algorithm for generating the outline of a level, walls and floors",
          "flag": false
        },
        {
          "text": "the language must support the ability to write and use custom level-generation algorithms",
          "flag": false
        },
        {
          "text": "language must support the procedural placement of objects",
          "flag": false
        },
        {
          "text": "the interpreter is capable of creating data and custom data types, including arrays and structures",
          "flag": false
        },
        {
          "text": "facilitates dynamic data handling and supports complex development requirements",
          "flag": false
        },
        {
          "text": "the interpreter supports exporting data to a JSON format",
          "flag": false
        }
      ]
    },
    {
      "number": 115,
      "originalText": "100Chapter 7.   Discussion\nvelopers  through  external  packages.   The  flexibility  of  the  interpreter  creates  the\npotential to support other formats like XML with minimal adjustments.\nPredefined Algorithms for Level Generation (M3)\nThe  language  currently  has  incorporated  one  predefined  algorithm  that  enables\nusers to generate the outline of a level, including walls and floors, using just a few\nlines of code. This feature significantly simplifies the initial development stages for\nusers focused on level design.\nCustom Level-Generation Algorithms (M4)\nCurrently,  developers  can  write  and  implement  their  own  level  generation  algo-\nrithms, which are flexible enough to support their specific needs.  This was tested\nusing  an  acceptance  test  on  custom-written  code  to  determine  if  the  code  could\ncreate a functioning level generation algorithm,  which it did,  demonstrating that\nthe interpreter can cater to specific needs. However, it would be beneficial to inter-\nview potential users, which could reveal additional needs helpful for them during\ndevelopment.\nProcedural Placement of Objects (M5)\nThe interpreter supports the procedural placement of objects within the map en-\nvironment, allowing for customisation in level design and interactivity.  However,\nthis functional feature is currently only possible with enemies,  walls,  floors,  and\nrooms.  This means that the current feature does not allow for placing loot or ob-\nstacles  without  users  having  to  generate  their  own  algorithm.   While  it  is  not  a\nnecessary feature for the acceptance test to pass in Unity, it could be a downside if\nusers require simple code features that would allow this.\n7.3.2    Should haves\nSShould have\nS2The language should be able to randomly generate values for proper-\nties for objects implemented for requirement M5\n✓\nTable 7.2:Should haves",
      "claims": []
    },
    {
      "number": 116,
      "originalText": "7.3.   Fulfilment of requirements101\nThe  language  should  be  able  to  randomly  generate  values  for  properties  for\nobjects implemented for requirement M5 (S2)\nThe  interpreter  supports  the  random  generation  of  values  to  the  properties  in\nstructs,  allowing  for  more  “randomness”  in  the  objects’  property  values.   How-\never, like the M5, this feature is currently only possible with enemies, walls, floors,\nand rooms.\n7.3.3    Could haves\nCCould have\nC3The language could include a utility function that displays the output\nof the user’s script\n✓\nTable 7.3:Could haves\nThe  language  could  include  a  utility  function  that  displays  the  output  of  the\nuser’s script (C3)\nThePrintmap()function  mentioned  in  the  built-in  functions  section  5.15  was\nimplemented and can display the map to the programmer in a grid like format in\nthe console instead of printing it to a file.",
      "claims": [
        {
          "text": "The language should be able to randomly generate values for properties for objects implemented for requirement M5 (S2)",
          "flag": false
        },
        {
          "text": "The interpreter supports the random generation of values to the properties in structs, allowing for more “randomness” in the objects’ property values.",
          "flag": false
        },
        {
          "text": "This feature is currently only possible with enemies, walls, floors, and rooms.",
          "flag": false
        },
        {
          "text": "The language could include a utility function that displays the output of the user’s script",
          "flag": false
        },
        {
          "text": "ThePrintmap()function mentioned in the built-in functions section 5.15 was implemented",
          "flag": false
        }
      ]
    },
    {
      "number": 117,
      "originalText": "",
      "claims": [
        {
          "text": "claim 1",
          "flag": false
        },
        {
          "text": "claim 2",
          "flag": false
        }
      ]
    },
    {
      "number": 118,
      "originalText": "Chapter 8\nFuture Work\n8.1    Introduction\nAs  CARL  is  a  language  designed  for  generating  JSON  representations  of  maps\nfor roguelike games, there are several areas for future development to enhance its\ncapabilities and user experience. This section outlines potential improvements and\nextensions that could be made to the language and its interpreter.\n8.2    Improvement of structs\nAs previously discussed, CARL currently supports the use of basic structs to repre-\nsent structured data. However, there is a significant need to expand this capability\nto  include  support  for  more  generic  structs,  similar  to  a  class  in  object-oriented\nprogramming.  This enhancement would allow developers to define custom data\ntypes tailored to specific needs, such as creating personalized coordinate systems\nor other unique data structures related to level scaling.\n8.3    Future scope rules for CARL\nAnother aspect of CARL mentioned in the discussion is an alternate implementa-\ntion of scope rules.  Currently, CARL uses dynamic variable scope rules, with the\nintention to make fully dynamic scope rules. However, for future implementation,\nit would be more beneficial for CARL to have fully static scope rules.  The reason\nfor  this  is  that  it  would  be  easier  for  users  to  know  the  exact  value  of  variables\nin their scope.  As mentioned in Target audience 2.4, some users might not be as\nexperienced  in  coding,  and  dynamic  scope  is  not  prevalent  in  most  well-known\nlanguages, which could cause confusion for new users of CARL.\nStatic scope rules are particularly good in a language with types because they en-\n103",
      "claims": [
        {
          "text": "As CARL is a language designed for generating JSON representations of maps for roguelike games",
          "flag": false
        },
        {
          "text": "there are several areas for future development to enhance its capabilities and user experience.",
          "flag": false
        },
        {
          "text": "This section outlines potential improvements and extensions that could be made to the language and its interpreter",
          "flag": false
        },
        {
          "text": "CARL currently supports the use of basic structs to represent structured data",
          "flag": false
        },
        {
          "text": "There is a significant need to expand this capability to include support for more generic structs, similar to a class in object-oriented programming.",
          "flag": false
        },
        {
          "text": "This enhancement would allow developers to define custom data types tailored to specific needs",
          "flag": false
        },
        {
          "text": "creating personalized coordinate systems or other unique data structures related to level scaling",
          "flag": false
        },
        {
          "text": "CARL uses dynamic variable scope rules",
          "flag": false
        },
        {
          "text": "it would be more beneficial for CARL to have fully static scope rules",
          "flag": false
        },
        {
          "text": "fully static scope rules would be easier for users to know the exact value of variables in their scope",
          "flag": false
        },
        {
          "text": "Some users might not be as experienced in coding, and dynamic scope is not prevalent in most well-known languages, which could cause confusion for new users of CARL.",
          "flag": false
        }
      ]
    },
    {
      "number": 119,
      "originalText": "104Chapter 8.   Future Work\nable  early  detection  of  type  errors,  improving  overall  code  reliability  and  safety.\nStatic  scoping  makes  the  scope  and  lifetime  of  variables  predictable,  simplifying\ncode readability and maintenance. Emacs Lisp, which initially used dynamic scop-\ning with types, transitioned to lexical (static) scoping due to these benefits, high-\nlighting  its  superiority  in  managing  variable  scope  and  enhancing  performance\n[15, 14]\n8.4    Enhancements in Error Handling\nThe current implementation of error handling in CARL is acceptable for basic op-\nerational needs.  However, there is significant room for improvement to make this\naspect of the interpreter more robust and user-friendly. An important enhancement\ncould be the development of an error handling mechanism that not only detects\nerrors but also pinpoints their location within the source code, such as indicating\nthe specific line on which a syntax error occurs.\n8.5    Increased Testing Coverage\nIncreasing  the  test  coverage  is  important  to  make  sure  that  CARL  is  reliable,  by\nmaking it harder to introduce bugs or accidentally break existing functionality. Ex-\npanding the scope and depth of testing would ensure a more thorough validation\nof the interpreter’s functionalities and error handling capabilities.  This would not\nonly help in catching and resolving potential issues before they affect end users,\nbut also aid in maintaining a stable and efficient development lifecycle.\n8.6    Implementation of Language Server Protocol (LSP) and\nTree-sitter\nImplementing  tools  to  assist  developers  within  their  preferred  editors  would  be\nhighly beneficial. The LSP is a protocol used by various editors to provide language\nfeatures like auto-completion, go-to-definition, and find-references.  Initially made\nfor Visual Studio Code, LSP has been widely adopted across many editors.\nTree-sitter is a parser generator tool and an incremental parsing library.  It is de-\nsigned  to  be  embedded  in  text  editors  to  provide  fast  and  accurate  syntax  high-\nlighting, code folding, and other features.",
      "claims": []
    },
    {
      "number": 120,
      "originalText": "8.7.   Improved Typing Syntax and Type Inference105\n8.7    Improved Typing Syntax and Type Inference\nCurrently, CARL defines variables’ types using postfix notation, similarly to Rust,\nbut  unlike  Rust,  lacks  type  inference.   This  means  that  a  developer  always  has\nto  specify  the  variable’s  type.   Adopting  a  more  familiar  syntax  like  that  of  C\nor  Java  for  writing  types  might  be  beneficial.   Alternatively,  if  type  inference  is\nimplemented, the syntax would not be an issue as developers would not need to\nmanually specify types in most cases.\n8.8    Proper Implementation of the Visitor Pattern\nThe Visitor Pattern is important for handling various AST elements efficiently. Each\nAST element can \"accept\" a visitor, which then performs specific operations on that\nelement, making it easier to expand the interpreter.\nHowever, the current implementation of CARL does not actually this pattern, de-\nspite some methods having similar names.  In the current implementation of vis-\niting  in  CARL,  an\nASTNodemighthave  avisitmethod,  which  is  designed  to\nprocess different types of Abstract Syntax Tree nodes within the language.\n1public  AstNode  visit(StatementNode  node) {\n2if (node.getNode ()  instanceof  AssignmentNode) {\n3visit(( AssignmentNode) node.getNode ());\n4} else if (node.getNode ()  instanceof  VariableDeclarationNode) {\n5visit(( VariableDeclarationNode) node.getNode ());\n6} else if (node.getNode ()  instanceof  FunctionCallNode) {\n7return  visit(( FunctionCallNode) node.getNode ());\n8}\n9\nListing 6:snippet of code showing type checking and casting\nIn the listing 6, thevisitmethod takes a genericStatementNodeas its parameter,\nand then usesinstanceofand casting to determine the specific type of node it\nis dealing with.  Once the type is determined, the node is cast to its specific type.\nThis  allows  the  method  to  call  the  appropriate\nvisitmethod  for  that  specific\nnode type.\nThe  existing  approach  is  good  enough  for  a  smaller  prototype,  but  can  quickly\nbecome difficult to expand on.  Even on the scale of the project, it was difficult to\nalways  ensure  that  all  cases  were  accounted  for,  and  missing  a  case  could  result\nin serious bugs.  The way that visitor pattern could be implemented would be as\nfollows:",
      "claims": []
    },
    {
      "number": 121,
      "originalText": "106Chapter 8.   Future Work\n1.Refactoring  AST  Nodes:  Introduce  anacceptmethod  in  eachASTNodeto\nfacilitate visitor operations.\n2.Defining  Visitor  Interfaces:  Create  a  visitor  interface  with  visit  methods  for\neach AST node type, such as expressions, statements, and declarations.\n3.Rewriting  current  Visitors:  Rewrite  the  way  it  currently  visits  the  classes  to\nsupport the new visitor implementation for specific operations.\n8.9    Non-fulfilled Requirements\nThere  are  several  features  that  were  planned  but  not  implemented  within  the\nproject scope. These are outlined in the MoSCoW prioritization framework:\n8.9.1    Should Have\nSShould have\nS1The language should be able to alter its generation based on parameters\nsuch as level or desired difficulty\nx\nTable 8.1:Should haves\nS1While it technically is possible to alter the map generation based on level, and is\nable to randomly scale the enemies by modifying the struct, it is missing the ability\nto  easily  pass  in  arguments,  such  as  level  or  difficulty  to  even  make  this  scaling\npossible.  This should be possible to accomplish by making a function call to the\nmain function defined in the CARL file as the last step of the interpretation after\nthe  interpreter  has  finished  analysing  the  code,  and  then  passing  the  arguments\nreceived in the main of java to the main of CARL.\n8.9.2    Could Have\nCCould havex\nC1Language could support multiple output formats, depending on user’s\nneeds\nx\nC2Language could support file separation of code, to allow for librariesx\nTable 8.2:Could haves\nC1Currently, the language only supports JSON, which is one of the more widely\nused formats. However, it is important to also support other formats used by other",
      "claims": []
    },
    {
      "number": 122,
      "originalText": "8.9.   Non-fulfilled Requirements107\napplications, such as Unreal Engine, which commonly use formats like XML and\nCSV.  Implementing  support  for  these  additional  formats  would  follow  a  similar\napproach  to  how  JSON  is  currently  handled.   This  would  involve  extending  the\nserialization functionality to include these formats, ensuring compatibility with a\nbroader range of development tools and workflows.\nC2If  the  language  aims  to  support  larger  projects,   it  is  crucial  to  support\nseparating  code  into  multiple  files  for  organisational  purposes.    This  could  be\napproached  in  several  ways.A  simple  approach  could  be  to  copy  the  entire\ncontents  of  included  files  into  the  main  file  at  the  start,  similar  to  what  is  done\nin C. This complicates calculating the exact location of errors, and naïve copying\nmight introduce unexpected errors for the user, such as those that may occur when\nusing the C Preprocessor carelessly.\nA  more  modern  approach  is  to  treat  files  as  modules,  and  when  such  a  file  is\nimported, whichever functions and variables have been defined in it are added to\nthe function and variable tables, unless those functions/variables are private.",
      "claims": [
        {
          "text": "Implementing support for additional formats would follow a similar approach to how JSON is currently handled.",
          "flag": false
        },
        {
          "text": "Extending serialization functionality to include these formats would ensure compatibility with a broader range of development tools and workflows.",
          "flag": false
        },
        {
          "text": "It is crucial to support separating code into multiple files for organisational purposes.",
          "flag": false
        },
        {
          "text": "A simple approach could be to copy the entire contents of included files into the main file at the start, similar to what is done in C.",
          "flag": false
        },
        {
          "text": "Naïve copying might introduce unexpected errors for the user.",
          "flag": false
        },
        {
          "text": "Treating files as modules and importing them would add functions and variables from the imported file to the function and variable tables.",
          "flag": false
        }
      ]
    },
    {
      "number": 123,
      "originalText": "",
      "claims": []
    },
    {
      "number": 124,
      "originalText": "Chapter 9\nConclusion\nThis  project  has  successfully  designed,  implemented,  and  tested  a  prototype  of\nCARL, a domain-specific programming language aimed at simplifying the gener-\nation  of  procedurally  generated  maps  for  roguelike  games.   The  development  of\nCARL was driven by a detailed analysis of the needs of indie game developers and\nthe limitations of existing tools.  By providing a language that integrates essential\nfeatures  such  as  data  creation  and  management,  data  serialization,  predefined\nand custom level-generation algorithms, and procedural object placement, CARL\naddresses the core challenges faced by developers in this genre.\nThe language design focused on balancing simplicity and flexibility, enabling both\nnovice and experienced developers to generate complex maps with minimal code.\nThe  use  of  ANTLR  for  generating  a  lexer  and  parser,  along  with  a  robust  inter-\npreter  developed  in  Java,  ensured  that  CARL  could  execute  code  efficiently  and\ncorrectly.  Extensive testing, including unit tests, integration tests, and acceptance\ntests, confirmed the language’s reliability and effectiveness in real-world scenarios.\nCARL’s   ability   to   export   data   in   JSON   format   ensures   compatibility   with\npopular game engines like Unity, enhancing its utility for developers.  The inclu-\nsion  of  built-in  functions  for  common  tasks,  such  as  map  generation  and  object\nplacement,  significantly  reduces  the  time  and  effort  required  for  development,\nwhile  the  support  for  custom  algorithms  provide  the  flexibility  needed  for  more\ncomplex and unique game designs.\nIn  the  project,   there  has  also  been  identified  areas  for  future  improvement.\nEnhancements  in  error  handling,  increased  testing  coverage,  the  implementation\nof a Language Server Protocol (LSP), and better typing syntax and type inference\nare all areas that could further refine CARL’s capabilities. Additionally, expanding\nsupport for procedural placement of a broader range of objects and improving the\n109",
      "claims": []
    },
    {
      "number": 125,
      "originalText": "110Chapter 9.   Conclusion\nuser experience through better documentation and user feedback mechanisms are\nessential steps for future development.",
      "claims": [
        {
          "text": "user experience is essential for future development",
          "flag": false
        }
      ]
    },
    {
      "number": 126,
      "originalText": "Bibliography\n[1]    AccelQ.The Essential Guide to Unit Testing. Accessed: 2024-04-23.url:https:\n//www.accelq.com/blog/unit-testing/.\n[2]    Rahul Awati.integration testing or integration and testing (IT). Accessed: 2024-\n04-26.url:https : / / www . techtarget . com / searchsoftwarequality /\ndefinition/integration-testing.\n[3]    Professor Giorgio Bacci.SS. Accessed: 2024-05-22. 2024.url:https://www.\nmoodle.aau.dk/course/view.php?id=50723.\n[4]    Kyle Benesch.Another Roguelike Tutorial 2021: Part 3 - Generating a dungeon.\nAccessed:  2024-05-24.url:https : / / libtcod . github . io / tutorials /\npython/2021/part-3.\n[5]    Kyle  Benesch.libtcod.  Accessed:  2024-05-24.url:https : / / github . com /\nlibtcod/libtcod.\n[6]    Kyle Benesch.python-tcod. Accessed: 2024-05-24.url:https://github.com/\nlibtcod/python-tcod.\n[7]    David Benyon.Designing User Experience: A guide to HCI, UX and interaction\ndesign. 4. ed. Accessed: 2024-05-24. Pearson, 2019.\n[8]    Boris.Dungeon Generation in Enter The Gungeon.  Accessed:  2024-02-26.url:\nhttps://www.boristhebrave.com/2019/07/28/dungeon-generation-in-\nenter-the-gungeon/.\n[9]    Randal E. Bryant and David R. O’Hallaron.ComputerSystems A Programmer’s\nPerspective. third global edition. Accessed: 2024-05-24. Pearson, 2016.\n[10]    Sydney  Butler.  “What  Is  a  Game  Engine?”  In:HowToGeek(May  2023).  Ac-\ncessed: 2024-05-24.url:https://www.howtogeek.com/888619/what-is-a-\ngame-engine/.\n[11]    Nicolas Casalini.Classengine.generator.map.RoomsLoader- TE4 1.4.0 Documenta-\ntion. Accessed: 2024-05-24.\n[12]    Nicolas Casalini.T-Engine4: Flexible roguelike game engine. Accessed: 2024-05-\n24.url:https://te4.org/te4.\n111",
      "claims": []
    },
    {
      "number": 127,
      "originalText": "112Bibliography\n[13]Enter  the  Gungeon  on  Steam.  Accessed:  2024-02-26.url:https : / / store .\nsteampowered.com/app/311690.\n[14]    Free  Software  Foundation.12.10.1  Dynamic  Binding.  Accessed:  2024-05-28.\nurl:https://www.gnu.org/software/emacs/manual/html_node/elisp/\nDynamic-Binding.html.\n[15]    Free Software Foundation.12.10.3 Lexical Binding. Accessed: 2024-05-28.url:\nhttps : / / www . gnu . org / software / emacs / manual / html _ node / elisp /\nLexical-Binding.html.\n[16]    FreeJack.Antlr4 Listeners and Visitors - which to implement? - Stack Overflow.\nAccessed: 2024-05-15.url:https://stackoverflow.com/a/20722151.\n[17]    Supergiant  Games.Hades  FAQ.  Accessed:  2024-02-23.url:https://www.\nsupergiantgames.com/blog/hades-faq/.\n[18]    Jeri R. Hanly and Elliot B. Koffman.Problem Solving and Program Design in C.\n8th. Accessed: 2024-05-24. Pearson.\n[19]    Hans  Hüttel.Transitions  and  trees,  An  introduction  to  Structural  Operational\nSemantics.  1st  ed.  Accessed:  2024-05-15.  Cambridge  university  press,  2010.\nChap. 1.\n[20]    Hans  Hüttel  and  Sean  Kristian  R.  Harbo.Implementing  a  programming  lan-\nguage Part 1: Lexing and parsing. Accessed: 2024-05-15. Springer, 2024.\n[21]    OpenCritic Inc.Best PC Games of All Time - OpenCritic. Accessed: 2024-02-23.\nurl:https://opencritic.com/browse/pc.\n[22]    OpenCritic Inc.Hades Reviews - OpenCritic. Accessed: 2024-02-23.url:https:\n//opencritic.com/game/10181/hades.\n[23]    JetBrains.Domain-Specific  Languages.  Accessed:  2024-02-26.url:https : / /\nwww.jetbrains.com/mps/concepts/domain-specific-languages/.\n[24]    Kyzrati.Procedural Map Generation.https://www.gridsagegames.com/blog/\n2014/06/procedural- map- generation/.  Accessed:  2024-05-24.  JUNE  13,\n2014.\n[25]    Jeff  Lait.The  Berlin  Interpretation.  Accessed:  2024-02-23.url:https : / /\ngroups . google . com / g / rec . games . roguelike . development / c / Orq2 _\n7HhMjI?pli=1.\n[26]    Joel  Lee.Roguelike  vs.  Roguelite  Games:  The  Difference  Explained  -  whatNerd.\nAccessed: 2024-02-23.url:https://whatnerd.com/what-is-a-roguelike-\nroguelite-difference/.\n[27]    Torben Ægidius Mogensen.Introduction to Compiler Design. 3rd ed. Accessed:\n2024-05-15. Springer, 2024. Chap. 3.",
      "claims": []
    },
    {
      "number": 128,
      "originalText": "Bibliography113\n[28]    Torben Ægidius Mogensen.Programming Language Design and Implementation.\n1st ed. Accessed: 2024-05-24. Springer, 2022.\n[29]    Professor Gabriela Montoya.OOP. Accessed: 2024-05-22. 2024.url:https:\n//www.moodle.aau.dk/pluginfile.php/3164338/mod_resource/content/\n4/October26.pdf.\n[30]    Noveltech.Generating a 2D map using the Random Walk algorithm.  Accessed:\n2024-02-22. 2017.url:https://www.noveltech.dev/procgen-random-walk.\n[31]    Shivam  Pradhan.Bresenham’s  Line  Generation  Algorithm.https : / / www .\ngeeksforgeeks.org/bresenhams-line-generation-algorithm/. Accessed:\n2024-05-28. 11 March 2024.\n[32]Roguelike.  Accessed:  2024-02-20.url:https://en.wikipedia.org/wiki/\nRoguelike.\n[33]    Robert W. Sebesta.Concepts of Programming Languages. 11th. Accessed: 2024-\n05-24. Pearson, 2016. Chap. 3.\n[34]    David  Silva.Original  Rogue  Game  (5.4.4).  Accessed:  2024-02-26.  2016.url:\nhttps://github.com/Davidslv/rogue/.\n[35]    stackoverflow.While, do-while, for loops in assembly language (emu8086).https:\n//stackoverflow.com/questions/28665528/while-do-while-for-loops-\nin-assembly-language-emu8086. Accessed: 2024-05-24. 2015.\n[36]Static and Dynamic Scoping. Accessed: 2024-05-13. 2023.url:https://www.\ngeeksforgeeks.org/static-and-dynamic-scoping/.\n[37]    Unity  Technologies.2D  Roguelike  -  Unity  Learn.  Accessed:  2024-05-24.url:\nhttps://learn.unity.com/project/2d-roguelike-tutorial.\n[38]    TutorialsPoint.Computer   Programming   -   Operators.https : / / www .\ntutorialspoint . com / computer _ programming / computer _ programming _\noperators.htm. Accessed: 2024-05-24. Accessed: 2024-03-04.\n[39]    Pixel Games UK.Rogue on Steam. Accessed: 2024-02-23.url:https://store.\nsteampowered.com/app/1443430/Rogue/.\n[40]    Wiki.Usenet  newsgroup.  Accessed:  2024-05-22.  2024.url:https : / / en .\nwikipedia.org/wiki/Usenet_newsgroup.\n[41]    Herbert Wolverson.Cellular Automata Maps. Accessed: 2024-02-26. 2019.url:\nhttps://bfnightly.bracketproductions.com/chapter_27.html.\n[42]    Herbert  Wolverson.What  is  Bracket-lib.  Accessed:  2024-05-24.url:https :\n//bfnightly.bracketproductions.com/bracket-lib/what_is_it.html.\n[43]    Yellowbrick.Navigating Challenges in the Indie Game Industry. Accessed: 2024-\n02-28.  2023.url:https : / / www . yellowbrick . co / blog / entertainment /\nnavigating-challenges-in-the-indie-game-industry.",
      "claims": [
        {
          "text": "Torben Ægidius Mogensen wrote a book called Programming Language Design and Implementation.",
          "flag": false
        },
        {
          "text": "Professor Gabriela Montoya taught OOP.",
          "flag": false
        },
        {
          "text": "Noveltech developed a 2D map using the Random Walk algorithm.",
          "flag": false
        },
        {
          "text": "Shivam Pradhan explained Bresenham's Line Generation Algorithm.",
          "flag": false
        },
        {
          "text": "Roguelike is a genre of video games.",
          "flag": false
        },
        {
          "text": "Robert W. Sebesta wrote a book called Concepts of Programming Languages.",
          "flag": false
        },
        {
          "text": "David Silva created the Original Rogue Game (5.4.4).",
          "flag": false
        },
        {
          "text": "stackoverflow discussed while, do-while, for loops in assembly language (emu8086).",
          "flag": false
        },
        {
          "text": "Static and Dynamic Scoping are concepts in computer science.",
          "flag": false
        },
        {
          "text": "Unity Technologies developed a 2D Roguelike tutorial.",
          "flag": false
        },
        {
          "text": "TutorialsPoint provided information on Computer Programming Operators.",
          "flag": false
        },
        {
          "text": "Pixel Games UK released Rogue on Steam.",
          "flag": false
        },
        {
          "text": "Wiki described Usenet newsgroups.",
          "flag": false
        },
        {
          "text": "Herbert Wolverson created Cellular Automata Maps and Bracket-elib.",
          "flag": false
        }
      ]
    },
    {
      "number": 129,
      "originalText": "114Bibliography\n[44]    Ondrej Zara.rot.js: ROguelike Toolkit in JavaScript. Accessed: 2024-05-24.url:\nhttps://ondras.github.io/rot.js/hp/.",
      "claims": []
    },
    {
      "number": 130,
      "originalText": "Appendix A\nExtra Criteria explained\nSimplicity and Orthogonality\nA  language  that  is  clear,  with  a  limited  set  of  well-defined  operations,  enhances\ncode  writing.   This  results  from  the  combination  of  simplicity,  which  provides\nstraightforward  ways  to  perform  tasks,  and  orthogonality,  allowing  the  mixing\nof basic operations in any combination without unexpected limitations.  Such at-\ntributes make the language predictable and user-friendly. As an example, Python’s\nsyntax for loops and list comprehensions enables powerful functionality with min-\nimal code.\nExpressivity\nA language’s capability to shortly express operations without compromising clarity\nenhances  its  expressivity.   Expressivity  can  be  done  in  different  ways,  and  can\naccelerate programming and enhances code readability.  This can be seen in some\nlanguage where if-statements can be swapped out with ternary operators, or other\nlanguages where i = i + 1, can be swapped out with i++.\nType Checking\nThis process checks the types of variables and expressions in the program to catch\nerrors before the program runs or while it is running. Languages with strong type\nsystems,  such  as  TypeScript,  which  verifies  types  at  compile-time,  help  prevent\ntype related errors, which makes programs more reliable.  The following example\nis TypeScript code that attempts to assign a number to a variable that’s supposed\nto only hold strings, showcasing how strong type checking helps avoid errors early.\n1let  username: string;\n2\n3username = \"Alice \";\n4\n115",
      "claims": []
    },
    {
      "number": 131,
      "originalText": "116Appendix A.  Extra Criteria explained\n5username = 123; //Code  fails  here\nListing A.1:Type checking in TypeScript\nException handling\nThis  characteristic  provides  a  structured  way  to  handle  runtime  errors,  allowing\nprograms  to  manage  unexpected  situations  easily.   Languages  that  offer  global\ntools for dealing with exceptions enable developers to write more robust and error-\nresistant code. Below is an example of using a try-except block in Python to handle\na division by zero error, demonstrating controlled error management.\n1def  divide(a, b):\n2try:\n3result = a / b\n4print(f\"Result: {result}\")\n5except  ZeroDivisionError:\n6print(\"Error: Cannot  divide  by zero.\")\n7\n8divide (10, 2)\n9\n10divide (10, 0)\nListing A.2:Python ’try-except’ block",
      "claims": [
        {
          "text": "This characteristic provides a structured way to handle runtime errors",
          "flag": false
        },
        {
          "text": "Languages that offer global tools for dealing with exceptions enable developers to write more robust and error-resistant code.",
          "flag": false
        },
        {
          "text": "Below is an example of using a try-except block in Python to handle a division by zero error",
          "flag": false
        },
        {
          "text": "demonstrating controlled error management",
          "flag": false
        }
      ]
    },
    {
      "number": 132,
      "originalText": "Appendix B\nContext-Free Grammar\n1grammar  CARL;\n2\n3//  Parser  rules\n4program : statement* EOF;\n5\n6statement\n7: assignment\n8| functionCall\n9| functionDefinition\n10| ifStatement\n11| whileLoop\n12| returnStatement\n13| structureDefinition\n14| importStatement\n15| variableDeclaration\n16| arrayDeclaration\n17| coordinateDeclaration\n18| methodCall\n19| propertyAssignment\n20;\n21\n22importStatement : ’import ’ STRING ;\n23functionDefinition : ’fn ’ IDENTIFIER  ’(’ parameterList? ’)’ ’->’ type\nblock ;\n24\n25\n26structureDefinition : ’var ’ IDENTIFIER  ’:’ structType  ’=’  ’{’\nvariableDeclaration* ’}’ ;\n27variableDeclaration : ’var ’ IDENTIFIER  ’:’ type  ’=’ (expression) ;\n28arrayDeclaration : ’var ’ IDENTIFIER  ’:’ legalArrayType\narrayOptionalIndex +;\n29\n30\n31arrayOptionalIndex : ’[’ expression? ’]’ ;\n117",
      "claims": []
    },
    {
      "number": 133,
      "originalText": "118Appendix B.  Context-Free Grammar\n32\n33legalArrayType :\n34’bool ’\n35| ’coord ’\n36| ’int ’\n37| ’string ’\n38| ’float ’\n39| IDENTIFIER\n40;\n41\n42\n43structType\n44: ’enemy ’\n45| ’floor ’\n46| ’wall ’\n47| ’room ’\n48;\n49\n50\n51type :\n52’bool ’\n53| ’int ’\n54| ’float ’\n55| ’coord ’\n56| ’void ’\n57| ’string ’\n58| IDENTIFIER\n59| legalArrayType  ’[’ expression?  ’]’ (’[’ expression?  ’]’)*\n60;\n61assignment : (IDENTIFIER | arrayAccess) ’=’ expression ;\n62propertyAssignment :   propertyAccess  ’=’ expression ;\n63functionCall : IDENTIFIER  ’(’ argumentList? ’)’ ;\n64methodCall : propertyAccess  ’(’ argumentList? ’)’ (’.’ IDENTIFIER)? ;\n65argumentList : expression (’,’ expression)* ;\n66parameterList : IDENTIFIER  ’:’ type (’,’ IDENTIFIER  ’:’ type)* ;\n67\n68expression\n69: primary # DummyPrimary\n70| ’!’ expression # Not\n71| expression  op=(’*’ | ’/’ |  ’%’) expression #\nMultiplicationDivisionModulus\n72| expression  op=(’+’ | ’-’) expression # AdditionSubtraction\n73| expression  op=(’<’ | ’<=’ | ’>’ | ’>=’ |  ’==’ |  ’!=’)  expression\n# Relation\n74| expression  op=(’AND ’ | ’OR ’)  expression # Logical\n75| expression  ’..’ expression # RandomBetween\n76;\n77\n78primary\n79: integer # Int\n80| fpNum # Float",
      "claims": [
        {
          "text": "bool is a type",
          "flag": false
        },
        {
          "text": "coord is a type",
          "flag": false
        },
        {
          "text": "int is a type",
          "flag": false
        },
        {
          "text": "string is a type",
          "flag": false
        },
        {
          "text": "float is a type",
          "flag": false
        },
        {
          "text": "IDENTIFIER is an option for type",
          "flag": false
        },
        {
          "text": "enemy, floor, wall, and room are struct types",
          "flag": false
        }
      ]
    },
    {
      "number": 134,
      "originalText": "119\n81| STRING # String\n82| IDENTIFIER # Identifier\n83| BOOL # Bool\n84| ’(’ expression  ’)’ # Parentheses\n85| functionCall # DummyFunctionCallExpr\n86| methodCall # DummyMethodCall\n87| arrayAccess # DummyArrayAccess\n88| propertyAccess # DummyPropertyAccess\n89;\n90\n91ifStatement : ’if’ expression  block ( ’else if’ expression  block )* (\n’else ’ block )? ;\n92whileLoop : ’while ’ expression  block ;\n93returnStatement : ’return ’ expression? ;\n94block : ’{’ (statement)* ’}’ ;\n95arrayAccess : IDENTIFIER  ’[’ expression  ’]’ (’[’ expression  ’]’)*;\n96propertyAccess : structType  ’.’ IDENTIFIER (’.’ IDENTIFIER)? ;\n97//Note: Coord  not  implemented\n98coordinateDeclaration : ’var ’ IDENTIFIER  ’:’ ’coord ’  ’=’ ’(’\nexpression  ’,’ expression  ’)’ ;\n99integer : ’-’? INT;\n100fpNum : ’-’? FLOAT;\n101\n102// Lexer  rules\n103INT : [0 -9]+ ;\n104FLOAT : [0 -9]*  ’.’ [0-9]+ ;\n105STRING : ’\"’ ~[\"]*  ’\"’ ;\n106BOOL : (’true ’ | ’false ’) ;\n107IDENTIFIER : [a-zA-Z_][a-zA -Z0 -9_]* ;\n108WS : [ \\t\\r\\n]+ -> skip ;\n109LINE_COMMENT :  ’//’ ~[\\r\\n]* -> skip ;",
      "claims": [
        {
          "text": "String is a data type",
          "flag": false
        },
        {
          "text": "Identifier is a data type",
          "flag": false
        },
        {
          "text": "Bool is a data type",
          "flag": false
        },
        {
          "text": "Parentheses are used to group expressions",
          "flag": false
        },
        {
          "text": "Function calls can be performed",
          "flag": false
        },
        {
          "text": "Method calls can be performed",
          "flag": false
        },
        {
          "text": "Array accesses can be performed",
          "flag": false
        },
        {
          "text": "Property access can be performed",
          "flag": false
        },
        {
          "text": "If statements can be used",
          "flag": false
        },
        {
          "text": "While loops can be used",
          "flag": false
        },
        {
          "text": "Return statements can be used",
          "flag": false
        },
        {
          "text": "Blocks of code can be defined",
          "flag": false
        },
        {
          "text": "Arrays can be accessed using brackets",
          "flag": false
        },
        {
          "text": "Properties can be accessed using dot notation",
          "flag": false
        }
      ]
    },
    {
      "number": 135,
      "originalText": "",
      "claims": []
    },
    {
      "number": 136,
      "originalText": "Appendix C\nAcceptance  test  written  in  CARL\nlanguage\n1var  size : int = 20\n2var  map : string[size][size]\n3var i : int = 0\n4var j : int = 0\n5while i < size{\n6j   = 0\n7while j < size {\n8map[i][j] = \"w\"\n9j = j+1\n10}\n11i = i+1\n12}\n13var  roomSize : int = room.size()\n14var  test : bool = true\n15while  roomSize  < 5 {\n16var  roomWidth : int = 3..5\n17var  roomHeight : int = 3..5\n18var x : int = 1.. size - roomWidth\n19var y : int = 2.. size - roomHeight\n20var  xTo : int = x + roomWidth\n21if xTo < size - 1{\n22xTo = xTo + 1\n23}\n24var  yTo : int = y + roomHeight\n25if yTo < size - 1{\n26yTo = yTo + 1\n27}\n28var  xFrom : int = x\n29if xFrom > 0{\n30xFrom = xFrom  - 1\n31}\n32var  yFrom : int = y\n121",
      "claims": []
    },
    {
      "number": 137,
      "originalText": "122Appendix C.  Acceptance test written in CARL language\n33if xFrom > 0{\n34xFrom = xFrom  - 1\n35}\n36test = true\n37while  xFrom  < xTo   {\n38while  yFrom  < yTo   {\n39var  check : string = map[xFrom][ yFrom]\n40if(check == \"f\"){\n41test = false\n42}\n43yFrom = yFrom +1\n44}\n45xFrom = xFrom + 1\n46}\n47if test {\n48xFrom   = x\n49xTo = x + roomWidth\n50yTo = y + roomHeight\n51while  xFrom  < xTo   {\n52yFrom = y\n53while  yFrom  < yTo   {\n54map[xFrom ][yFrom] = \"f\"\n55yFrom = yFrom +1\n56}\n57xFrom = xFrom +1\n58}\n59var  newRoom : room = {\n60var x : int = x\n61var y : int = y\n62var  roomWidth : int = roomWidth\n63var  roomHeight : int = roomHeight\n64}\n65}\n66roomSize =   room.size()\n67\n68}\n69i = 0\n70var  toRooms : int   = roomSize  - 1\n71while i < toRooms{\n72var  xFrom : int = room.get(i).x + room.get(i).roomWidth / 2\n73var  yFrom : int = room.get(i).y + room.get(i).roomHeight / 2\n74var  nextI : int = i+1\n75var  xTo : int = room.get(nextI).x + room.get(nextI).roomWidth\n/ 2\n76var  yTo : int = room.get(nextI).y + room.get(nextI).roomHeight\n/ 2\n77if xFrom < xTo{\n78while  xFrom  < xTo{\n79map[xFrom ][yFrom] = \"f\"\n80xFrom = xFrom +1\n81}",
      "claims": []
    },
    {
      "number": 138,
      "originalText": "123\n82}\n83else{\n84while  xTo < xFrom{\n85map[xFrom ][yFrom] = \"f\"\n86xFrom = xFrom -1\n87}\n88}\n89if yFrom < yTo{\n90while  yFrom  < yTo{\n91map[xFrom ][yFrom] = \"f\"\n92yFrom = yFrom +1\n93}\n94}\n95else{\n96while  yTo < yFrom{\n97map[xFrom ][yFrom] = \"f\"\n98yFrom = yFrom -1\n99}\n100}\n101i = i + 1\n102}\n103\n104var  playerX : int = room.get(toRooms).x .. room.get(toRooms).x + room.\nget(toRooms).roomWidth\n105var  playerY : int = room.get(toRooms).y .. room.get(toRooms).y + room.\nget(toRooms).roomHeight\n106map[playerX ][ playerY] = \"p\"\n107writeToFile ()\nListing C.1:acceptance test written in CARL language",
      "claims": []
    },
    {
      "number": 139,
      "originalText": "",
      "claims": []
    },
    {
      "number": 140,
      "originalText": "Appendix D\nProgramming  in  the  CARL  script-\ning language\n(Note:  This file is a copy oflanguage.md,  found in the project root,  that is auto-\nmatically converted toL\nA\nT\nE\nX.)\nIn  general,  CARL  is  a  simple  imperative  language.   Statements  are  separated  by\nnewlines (no semicolons), and are executed one after the other.\nD.1    Variables\nD.1.1    Declaration\nNew variables are defined using the syntax:\nvar <identifier>: <type> = <value>\nThey can be edited without thevarkeyword or specifying type:\n<identifier> = <value>\nAs an example, this code:\nvar foo: int = 3\nprint(foo)\nfoo = foo + 1\nprint(foo)\nwould output:\n3\n4\nD.1.2    Primitive Types\nCARL has the following primitive types:\n125",
      "claims": [
        {
          "text": "Programming in the CARL script- ing language",
          "flag": false
        },
        {
          "text": "This file is a copy oflanguage.md, found in the project root, that is automatically converted to LATEX.",
          "flag": false
        },
        {
          "text": "In general, CARL is a simple imperative language",
          "flag": false
        },
        {
          "text": "Statements are separated by newlines (no semicolons), and are executed one after the other",
          "flag": false
        },
        {
          "text": "New variables are defined using the syntax: var <identifier>: <type> = <value>",
          "flag": false
        },
        {
          "text": "They can be edited without thevar keyword or specifying type: <identifier> = <value>",
          "flag": false
        },
        {
          "text": "CARL has the following primitive types",
          "flag": false
        }
      ]
    },
    {
      "number": 141,
      "originalText": "126Appendix D.  Programming in the CARL scripting language\nTypeExplanationExamples\nboolBoolean value: eithertrueorfalse.true,false\nintInteger value: Can be any whole number, either1,2,32194,-900000\npositive or negative (currently limited to signed\n32-bit integers)\nfloatFloating-point value: Can be any real number,1.0,0.0,-10000.0,1.404001\nwith 64-bit precision.\nstringAny text, represented as a string of characters.\"Hello, World!\", \"123\"\nOn top of this, the language also supports arrays\n1\nand structs\n2\n.\nD.1.3    Arrays\nCARL  supports  arrays.   Arrays  have  a  static  size,  can  have  multiple  dimensions,\nand require all elements to have the same type.\nA one-dimensional array containing five integers is declared like this:\nvar myArray: int[5]\nAs  stated  before,  there  can  be  as  many  dimensions  as  needed.   For  example,  to\ncreate a three-dimensional array where the dimensions have sizes of 10, 20, and 30\nrespectively, the following code is used:\nvar threeDimensionalArray: int[10][20][30]\nAn array can be of any primitive type,  which does not include the array type or\nany of the struct types.  If an array within an array is needed, a two-dimensional\narray can be utilised instead.\nArrays are zero-indexed, and can be accessed by writing their identifier, followed\nby the indices in square brackets. For example, to print the 4th element ofmyArray\n(note the zero-indexing):\nprint(myArray[3])\nD.1.4    Structs\nThere are currently four structured data types in CARL:enemy,floor,wall, and\nroom. Each of these structs has a similar construction:\nvar <identifier>: <structType> = {\nvar <property>: <type> = <value>\nvar <property>: <type> = <value>\n...\n}\nThe property can be any variable of any type, but some struct types may require\ncertain properties (such assymbolforwalls).\n1\n#Arrays\n2\n#Structs",
      "claims": []
    },
    {
      "number": 142,
      "originalText": "D.1.   Variables127\nWhen a struct is declared, it is added to a list maintained by the interpreter, and\nthey may be used for builtin functions.\nEnemy\nTheenemystruct is used to represent non-playable characters on the map.  It has\ntwo properties that are used by builtin functions:difficulty, andsymbol.\nNameTypeExplanation\ndifficulty  intUsed bygenerateSpawns()to spawn them. Is substracted from\nthe given value when put in map\nsymbol      stringThe enemy’s symbol on the map\nThe  following  is  an  example  of  an  enemy,  in  this  case  an  orc.   It  uses  custom\nattributes, instead of just relying on inbuilt functions:\nvar Orc : enemy = {\nvar difficulty : int = 1\nvar health : int = 200\nvar symbol : string= \"O\"\n}\nFloor\nFloor is used to define a new default floor, or a new floor you want to use a custom\nalgorithm.\nNameTypeExplanation\nsymbol  stringused instead of default being f\nWall\nWall is used to define a new default wall, or a new wall you want to use a custom\nalgorithm.\nNameTypeExplanation\nsymbol  stringused instead of default being w",
      "claims": [
        {
          "text": "When a struct is declared, it is added to a list maintained by the interpreter, and they may be used for builtin functions.",
          "flag": false
        },
        {
          "text": "The enemy struct is used to represent non-playable characters on the map.",
          "flag": false
        },
        {
          "text": "It has two properties that are used by builtin functions: difficulty, and symbol.",
          "flag": false
        },
        {
          "text": "difficulty intUsed by generateSpawns()to spawn them. Is substracted from the given value when put in map.",
          "flag": false
        },
        {
          "text": "symbol stringThe enemy's symbol on the map.",
          "flag": false
        }
      ]
    },
    {
      "number": 143,
      "originalText": "128Appendix D.  Programming in the CARL scripting language\nRoom\nNameTypeExplanation\nx       intRepresents the X coordinate of the room’s spawn point\ny       intRepresents the Y coordinate of the room’s spawn point\nwidth   intRepresents the width of the room\nheight  intRepresents the height of the room\nD.2    Operators\nCARL supports the following arithmetic operators:\nOperatorExampleExplanation\n*         foo * barMultiplies the two operands.\n/         foo / barDivides the first operand by the second.\n‘\n+         foo + barAdds the two operands.\n-         foo - barSubtracts the first operand by the second.\n..        foo..barReturns a random number between the two operands. Will return\nan integer if both operands are integers, or a float if one of the\noperands are floats.\nCARL supports the following relational operators:\nOperatorExampleExplanation\n<         foo < barReturnstrueif the first operand is less than the second.\n<=        foo <= barReturnstrueif the first operand is less than or equal to the second.\n==        foo == barReturnstrueif the first operand is equal to the second.\n>=        foo >= barReturnstrueif the first operand is greater than or equal to the second.\n>         foo > barReturnstrueif the first operand is greater than the second.\n!=        foo != barReturnstrueif the first operand is not equal to the second.\nCARL supports the following logical operators:\nOperatorExampleExplanation\n!         !fooNegation operator. If the operand evaluates totrue, returnsfalse,\nand vice versa.\nAND       foo AND barReturnstrueif the first operand and the second operand are both\ntrue. Returnsfalseotherwise.\nOR        foo OR barReturnstrueif either the first operand or the second operand are\ntrue. Returnsfalseonly if both operands arefalse.",
      "claims": []
    },
    {
      "number": 144,
      "originalText": "D.3.   Control structures129\nD.3    Control structures\nCARL has two main ways to control program flow: if statements, and while loops.\nD.3.1    If statements\nAn  if  statement  allows  your  program  to  choose  whether  to  execute  one  or  more\npieces of code, based on one or more conditionals.  The following is the structure\nof a simple if statement:\nif <condition> {\n<code>\n}\nIf<condition>is  true,  then<code>will  execute.  Otherwise,  the  interpreter  will\nskip<code>and simply continue interpretation after the statement.\nAn if statement can also have an else clause, or one or more else-if clauses.  If the\nfirst condition is false, the interpreter will go through each else-if statement’s con-\ndition, until one of them evaluates totrue. If all of them arefalse, the interpreter\nwill execute the code in the else clause.  If there is no else clause,  the interpreter\nwill continue interpretation after the whole structure.  Here is an example of an if\nstatement with several else-if’s and else’s:\nif x == 5 {\nprint(\"x is five\")\n} else if x == 10 {\nprint(\"x is ten\")\n} else {\nprint(\"x is neither five or ten\")\n}\nNote that parentheses around the condition are not required.\nD.3.2    While loops\nWhile loops have a similar structure to if statements:\nwhile <condition> {\n<code>\n}\nIt repeats<code>for as long as<condition>holds.  Here is an example of a while\nloop, that will print the numbers 1 to 5:\nvar i: int = 1\nwhile i <= 5 {\nprint(i)\ni = i + 1\n}",
      "claims": [
        {
          "text": "CARL has two main ways to control program flow",
          "flag": false
        },
        {
          "text": "An if statement allows your program to choose whether to execute one or more pieces of code, based on one or more conditionals",
          "flag": false
        },
        {
          "text": "If <condition> is true, then <code> will execute.",
          "flag": false
        },
        {
          "text": "Otherwise, the interpreter will skip <code> and simply continue interpretation after the statement",
          "flag": false
        },
        {
          "text": "An if statement can also have an else clause, or one or more else-if clauses",
          "flag": false
        },
        {
          "text": "If the first condition is false, the interpreter will go through each else-if statement's condition, until one of them evaluates to true.",
          "flag": false
        },
        {
          "text": "If all of them are false, the interpreter will execute the code in the else clause.",
          "flag": false
        },
        {
          "text": "If there is no else clause, the interpreter will continue interpretation after the whole structure",
          "flag": false
        },
        {
          "text": "Note that parentheses around the condition are not required.",
          "flag": false
        },
        {
          "text": "While loops have a similar structure to if statements",
          "flag": false
        },
        {
          "text": "It repeats <code> for as long as <condition> holds",
          "flag": false
        }
      ]
    },
    {
      "number": 145,
      "originalText": "130Appendix D.  Programming in the CARL scripting language\nD.4    Functions\nD.4.1    Defining custom functions\nFunctions can be defined using the syntax:\nfn <name>(<list of parameters>) -> <returnType> {\n<code>\n}\nThe list of parameters is declared like in Rust or Python.  An example can be seen\nhere:\nfn test(firstArg: string) -> void {\nprint(firstArg)\n}\ntest(\"test\")\nThis would define a functiontest(), which takes a string as a parameter. The final\nline of the example runs the function, which will printtestin the console.\nD.4.2    Builtin functions\nAs discussed above, CARL does allow the definition of custom functions, but sev-\neral functions have been deemed important enough to be natively supported, and\ndo not need to be defined first.\nprint\nprint()is  the  basic  print  function  that  most  langauge  will  have.   It  prints  the\nprovided arguments to the console. This works both for literals and for variables.\nIf more than one argument is provided, these are printed with whitespace between\nthem.\nFor example, a simple hello world would look like this:\nprint(\"hello\", \"world!\")\ngenerateMap\nThegenerateMap()function will generate the skeleton of the map, in the form of\na two-dimensional array. It takes two arguments: the width and height of the map.\nThis skeleton will be filled by the symbol of the first wall struct in the global struct\narray, orwif there isn’t one.\ngenerateRooms\nThegenerateRooms()function will generate rooms in the map, and add them to\nthe global structs array.  Each room will have a random height, width, x, and y.  It",
      "claims": []
    },
    {
      "number": 146,
      "originalText": "D.4.   Functions131\ntakes three parameters, which refer to:\n1.  The amount of rooms to generate\n2.  The minimum room size\n3.  The maximum room size\nEach room will be filled with the symbol of the first floor struct in the global struct\narray, orfif there is none.\ngenerateCorridors\ngenerateCorridors()will generate corridors between each room and the next one.\ngenerateSpawns\ngenerateSpawns()will place enemies on random floor tiles in all rooms except for\nthe last one, according to the specified difficutly, and then at the end it will place\nthe player too.\nprintMap\nprintMap()will  print  out  what  the  map  currently  looks  like,  with  all  the  other\ninformation, like attributes, at the bottom.  CallingprintMap()after running,  for\nexample,generateMap(20, 20), will print out a 20x20 matrix entirely filled with\nwalls, and then the default information about the wall, floor and player below.\nwriteToFile\nwriteToFile()does the exact same thing asprintMap(), but instead of sending it\nto the standard output, it will save to a file calledmap.json.",
      "claims": [
        {
          "text": "Functions 131 takes three parameters",
          "flag": false
        },
        {
          "text": "The amount of rooms to generate is referred to",
          "flag": false
        },
        {
          "text": "The minimum room size is referred to",
          "flag": false
        },
        {
          "text": "The maximum room size is referred to",
          "flag": false
        },
        {
          "text": "Each room will be filled with the symbol of the first floor struct in the global struct array",
          "flag": false
        },
        {
          "text": "There is an or if there is none",
          "flag": false
        },
        {
          "text": "generateCorridors() will generate corridors between each room and the next one",
          "flag": false
        },
        {
          "text": "generateSpawns() will place enemies on random floor tiles in all rooms except for the last one, according to the specified difficulty, and then at the end it will place the player too",
          "flag": false
        },
        {
          "text": "printMap() will print out what the map currently looks like, with all the other information, like attributes, at the bottom",
          "flag": false
        },
        {
          "text": "Calling printMap() after running, for example, generateMap(20, 20), will print out a 20x20 matrix entirely filled with walls, and then the default information about the wall, floor and player below",
          "flag": false
        },
        {
          "text": "writeToFile() does the exact same thing as printMap(), but instead of sending it to the standard output, it will save to a file called map.json",
          "flag": false
        }
      ]
    }
  ]
}